/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => ListCalloutsPlugin
});

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a string");
  }
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// src/main.ts
var import_obsidian5 = __toModule(require("obsidian"));

// src/extension.ts
var import_language = __toModule(require("@codemirror/language"));
var import_state = __toModule(require("@codemirror/state"));
var import_view = __toModule(require("@codemirror/view"));
var import_obsidian = __toModule(require("obsidian"));
var setConfig = import_state.StateEffect.define();
var CalloutBackground = class extends import_view.WidgetType {
  toDOM() {
    return createSpan({
      cls: "lc-list-bg",
      attr: {
        "aria-hidden": "true"
      }
    });
  }
  eq() {
    return true;
  }
};
var CalloutMarker = class extends import_view.WidgetType {
  constructor(char, icon) {
    super();
    this.char = char;
    this.icon = icon;
  }
  toDOM() {
    return createSpan({
      text: this.char,
      cls: "lc-list-marker",
      attr: {
        "aria-hidden": "true"
      }
    }, (s) => {
      if (this.icon) {
        (0, import_obsidian.setIcon)(s, this.icon);
      }
    });
  }
  eq(widget) {
    return widget.char === this.char && widget.icon === this.icon;
  }
};
var calloutDecoration = (char, color) => import_view.Decoration.line({
  attributes: {
    class: "lc-list-callout",
    style: `--lc-callout-color: ${color}`,
    "data-callout": char
  }
});
var calloutsConfigField = import_state.StateField.define({
  create() {
    return { callouts: {}, re: null };
  },
  update(state, tr) {
    for (const e of tr.effects) {
      if (e.is(setConfig)) {
        state = e.value;
      }
    }
    return state;
  }
});
function buildCalloutDecos(view, state) {
  const config = state.field(calloutsConfigField);
  if (!(config == null ? void 0 : config.re) || !view.visibleRanges.length)
    return import_view.Decoration.none;
  const builder = new import_state.RangeSetBuilder();
  const lastRange = view.visibleRanges[view.visibleRanges.length - 1];
  const tree = (0, import_language.ensureSyntaxTree)(state, lastRange.to, 50);
  const { doc } = state;
  let lastEnd = -1;
  for (const { from, to } of view.visibleRanges) {
    tree.iterate({
      from,
      to,
      enter({ type, from: from2, to: to2 }) {
        if (from2 <= lastEnd)
          return;
        const prop = type.prop(import_language.tokenClassNodeProp);
        if (prop && /formatting-list/.test(prop)) {
          const { from: lineFrom, to: to3, text } = doc.lineAt(from2);
          const match = text.match(config.re);
          const callout = match ? config.callouts[match[2]] : null;
          lastEnd = to3;
          if (callout) {
            const labelPos = lineFrom + match[1].length;
            builder.add(lineFrom, lineFrom, calloutDecoration(callout.char, callout.color));
            builder.add(lineFrom, lineFrom, import_view.Decoration.widget({ widget: new CalloutBackground(), side: -1 }));
            builder.add(labelPos, labelPos + callout.char.length, import_view.Decoration.replace({
              widget: new CalloutMarker(callout.char, callout.icon)
            }));
          }
        }
      }
    });
  }
  return builder.finish();
}
var calloutExtension = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = buildCalloutDecos(view, view.state);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.transactions.some((tr) => tr.effects.some((e) => e.is(setConfig)))) {
      this.decorations = buildCalloutDecos(update.view, update.state);
    }
  }
}, {
  decorations: (v) => v.decorations
});

// src/postProcessor.ts
var import_obsidian2 = __toModule(require("obsidian"));
function getFirstTextNode(li) {
  var _a;
  for (const node of Array.from(li.childNodes)) {
    if (node.nodeType === document.ELEMENT_NODE && node.classList.contains("tasks-list-text")) {
      const descriptionNode = node.firstElementChild;
      if (descriptionNode == null ? void 0 : descriptionNode.classList.contains("task-description")) {
        const textNode = (_a = descriptionNode.firstElementChild) == null ? void 0 : _a.firstChild;
        if (textNode.nodeType === document.TEXT_NODE) {
          return textNode;
        }
      }
    }
    if (node.nodeType === document.ELEMENT_NODE && node.tagName === "P") {
      return node.firstChild;
    }
    if (node.nodeType !== document.TEXT_NODE) {
      continue;
    }
    if (node.nodeValue.trim() === "") {
      continue;
    }
    return node;
  }
  return null;
}
function wrapLiContent(li) {
  const toReplace = [];
  let insertBefore = null;
  for (let i = 0, len = li.childNodes.length; i < len; i++) {
    const child = li.childNodes.item(i);
    if (child.nodeType === document.ELEMENT_NODE) {
      const el = child;
      if (el.hasClass("list-collapse-indicator") || el.hasClass("list-bullet")) {
        continue;
      }
      if (["UL", "OL"].includes(el.tagName)) {
        insertBefore = child;
        break;
      }
    }
    toReplace.push(child);
  }
  const wrapper = createSpan({ cls: "lc-li-wrapper" });
  toReplace.forEach((node) => wrapper.append(node));
  if (insertBefore) {
    insertBefore.before(wrapper);
  } else {
    li.append(wrapper);
  }
}
function buildPostProcessor(getConfig) {
  return (el, ctx) => __async(this, null, function* () {
    var _a;
    const config = getConfig();
    if ((_a = ctx.promises) == null ? void 0 : _a.length) {
      yield Promise.all(ctx.promises);
    }
    el.findAll("li").forEach((li) => {
      const node = getFirstTextNode(li);
      if (!node)
        return;
      const text = node.textContent;
      if (!text)
        return;
      const match = text.match(config.re);
      const callout = match ? config.callouts[match[1]] : null;
      if (callout) {
        li.addClass("lc-list-callout");
        li.setAttribute("data-callout", callout.char);
        li.style.setProperty("--lc-callout-color", callout.color);
        node.replaceWith(createFragment((f) => {
          f.append(createSpan({
            cls: "lc-list-marker",
            text: text.slice(0, callout.char.length)
          }, (span) => {
            if (callout.icon) {
              (0, import_obsidian2.setIcon)(span, callout.icon);
            }
          }));
          f.append(text.slice(callout.char.length));
        }));
        wrapLiContent(li);
      }
    });
  });
}

// src/settings.ts
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/fuse.js/dist/fuse.esm.js
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
var BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
var AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = __spreadValues(__spreadValues({}, Config), options);
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/iconList.ts
var import_obsidian3 = __toModule(require("obsidian"));
var iconListRaw = (0, import_obsidian3.getIconIds)().map((id) => ({
  id,
  aliases: []
}));
var iconList = new Fuse(iconListRaw, {
  threshold: 0.1,
  minMatchCharLength: 2,
  keys: ["id", "aliases"]
});

// src/settings.ts
function buildSettingCallout(root, callout) {
  root.empty();
  root.createDiv({
    cls: "markdown-source-view cm-s-obsidian mod-cm6 is-readable-line-width is-live-preview"
  }, (mockSrcView) => {
    mockSrcView.createDiv({
      cls: "HyperMD-list-line HyperMD-list-line-1 lc-list-callout cm-line",
      attr: {
        style: `text-indent: -8px; padding-left: 12px; --lc-callout-color: ${callout.color}`
      }
    }, (mockListLine) => {
      mockListLine.createSpan({
        cls: "cm-formatting cm-formatting-list cm-formatting-list-ul cm-list-1"
      }, (span) => {
        span.createSpan({ cls: "list-bullet", text: "-" });
        span.appendText(" ");
      });
      mockListLine.createSpan({ cls: "lc-list-bg" });
      mockListLine.createSpan({ cls: "lc-list-marker" }, (span) => {
        if (callout.icon) {
          (0, import_obsidian4.setIcon)(span, callout.icon);
        } else {
          span.appendText(callout.char);
        }
      });
      mockListLine.createSpan({
        cls: "cm-list-1",
        text: " Sed eu nisl rhoncus, consectetur mi quis, scelerisque enim."
      });
    });
  });
}
function attachIconMenu(btn, onSelect) {
  let menuRef = null;
  const btnEl = btn.buttonEl;
  btn.onClick((e) => {
    e.preventDefault();
    const scrollParent = btnEl.closest(".vertical-tab-content");
    const destroyEventHandlers = () => {
      btnEl.win.removeEventListener("click", clickOutside);
      scrollParent.removeEventListener("scroll", scroll);
    };
    const clickOutside = (e2) => {
      if (menuRef) {
        if (!menuRef.contains(e2.targetNode)) {
          menuRef.detach();
          menuRef = null;
          destroyEventHandlers();
        }
      } else {
        destroyEventHandlers();
      }
    };
    const calcMenuPos = () => {
      let pos = `top: ${btnEl.offsetTop + btnEl.offsetHeight + 2 - scrollParent.scrollTop}px;`;
      if (import_obsidian4.Platform.isMobile) {
        pos += ` right: ${btnEl.offsetParent.clientWidth - (btnEl.offsetLeft + btnEl.offsetWidth)}px;`;
      } else {
        pos += ` left: ${btnEl.offsetLeft}px;`;
      }
      menuRef.style.cssText = pos;
    };
    const scroll = () => {
      if (menuRef) {
        calcMenuPos();
      } else {
        destroyEventHandlers();
      }
    };
    if (menuRef) {
      destroyEventHandlers();
      menuRef.detach();
      menuRef = null;
      return;
    }
    createDiv("lc-menu", (menu) => {
      menuRef = menu;
      btnEl.after(menuRef);
      calcMenuPos();
      const iconEls = {};
      menu.createDiv("lc-menu-search", (el) => {
        el.createEl("input", {
          attr: {
            type: "text",
            placeholder: "Search..."
          }
        }, (input) => {
          activeWindow.setTimeout(() => {
            input.focus();
          });
          const handler = (0, import_obsidian4.debounce)(() => {
            const res = iconList.search(input.value);
            if (!input.value) {
              (0, import_obsidian4.getIconIds)().forEach((icon) => {
                iconList2.append(iconEls[icon]);
              });
              return;
            }
            iconList2.empty();
            res.forEach((r) => {
              iconList2.append(iconEls[r.item.id]);
            });
          }, 250, true);
          input.addEventListener("input", handler);
        });
      });
      const iconList2 = menu.createDiv("lc-menu-icons", (el) => {
        (0, import_obsidian4.getIconIds)().forEach((icon) => {
          el.createDiv({
            cls: "clickable-icon",
            attr: {
              "data-icon": icon
            }
          }, (item) => {
            iconEls[icon] = item;
            (0, import_obsidian4.setIcon)(item, icon);
            item.onClickEvent(() => {
              btn.buttonEl.empty();
              btn.setIcon(icon);
              onSelect(icon);
              destroyEventHandlers();
              menuRef.detach();
              menuRef = null;
            });
          });
        });
      });
    });
    btnEl.win.setTimeout(() => {
      btnEl.win.addEventListener("click", clickOutside);
      scrollParent.addEventListener("scroll", scroll);
    }, 10);
  });
}
function buildSetting(containerEl, plugin, index, callout, onDelete) {
  containerEl.createDiv({ cls: "lc-setting" }, (el) => {
    const calloutContainer = el.createDiv({ cls: "lc-callout-container" });
    buildSettingCallout(calloutContainer, callout);
    el.createDiv({ cls: "lc-input-container" }, (inputContainer) => {
      new import_obsidian4.TextComponent(inputContainer).setValue(callout.char).onChange((value) => {
        if (!value)
          return;
        plugin.settings[index].char = value;
        plugin.saveSettings();
        buildSettingCallout(calloutContainer, plugin.settings[index]);
      });
      const iconBtn = new import_obsidian4.ButtonComponent(inputContainer).then((btn) => {
        if (callout.icon) {
          btn.setIcon(callout.icon);
        } else {
          btn.setButtonText("Set Icon");
        }
        attachIconMenu(btn, (icon) => {
          if (icon == null) {
            delete plugin.settings[index].icon;
          } else {
            plugin.settings[index].icon = icon;
          }
          plugin.saveSettings();
          buildSettingCallout(calloutContainer, plugin.settings[index]);
        });
      });
      new import_obsidian4.ButtonComponent(inputContainer).then((btn) => {
        btn.setButtonText("Clear Icon");
        btn.onClick(() => {
          delete plugin.settings[index].icon;
          iconBtn.buttonEl.empty();
          iconBtn.setButtonText("Set Icon");
          plugin.saveSettings();
          buildSettingCallout(calloutContainer, plugin.settings[index]);
        });
      });
      if (callout.custom) {
        const [r, g, b] = callout.color.split(",").map((v) => parseInt(v.trim(), 10));
        const color = new import_obsidian4.ColorComponent(inputContainer).setValueRgb({ r, g, b }).onChange((_value) => {
          const { r: r2, g: g2, b: b2 } = color.getValueRgb();
          plugin.settings[index].color = `${r2}, ${g2}, ${b2}`;
          plugin.saveSettings();
          buildSettingCallout(calloutContainer, plugin.settings[index]);
        });
      }
      if (callout.custom) {
        const rightAlign = inputContainer.createDiv({
          cls: "lc-input-right-align"
        });
        new import_obsidian4.ButtonComponent(rightAlign).setButtonText("Delete").setWarning().onClick((_e) => {
          onDelete(index);
        });
      }
    });
  });
}
function buildNewCalloutSetting(containerEl, plugin, onSubmit) {
  const callout = {
    char: "",
    color: "158, 158, 158",
    icon: null,
    custom: true
  };
  containerEl.createDiv({ cls: "lc-setting" }, (settingContainer) => {
    settingContainer.createDiv({ cls: "setting-item-name" }, (e) => e.setText("Create a new Callout"));
    settingContainer.createDiv({ cls: "setting-item-description" }, (e) => e.setText("Create additional list callout styles."));
    const calloutContainer = settingContainer.createDiv({
      cls: "lc-callout-container"
    });
    const inputContainer = settingContainer.createDiv({
      cls: "lc-input-container"
    });
    const char = new import_obsidian4.TextComponent(inputContainer).setValue("").setPlaceholder("...").onChange((value) => {
      callout.char = value;
      redraw();
    });
    const icon = new import_obsidian4.ButtonComponent(inputContainer).setButtonText("Set Icon");
    attachIconMenu(icon, (icon2) => {
      if (icon2 == null) {
        delete callout.icon;
      } else {
        callout.icon = icon2;
      }
      redraw();
    });
    const color = new import_obsidian4.ColorComponent(inputContainer).setValueRgb({ r: 127, g: 127, b: 127 }).onChange((_value) => {
      const { r, g, b } = color.getValueRgb();
      callout.color = `${r}, ${g}, ${b}`;
      redraw();
    });
    const rightAlign = inputContainer.createDiv({
      cls: "lc-input-right-align"
    });
    const submit = new import_obsidian4.ButtonComponent(rightAlign).setButtonText("Create").setDisabled(true).onClick(() => {
      onSubmit(callout);
    });
    function redraw() {
      buildSettingCallout(calloutContainer, callout);
      const hasNoCharacter = callout.char.length === 0;
      const hasConflictingCharacter = plugin.settings.find((c) => c.char === char.getValue()) !== void 0;
      submit.setDisabled(hasNoCharacter || hasConflictingCharacter);
    }
    redraw();
  });
}
var ListCalloutSettings = class extends import_obsidian4.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setDesc(createFragment((f) => {
      f.appendText("See the Style Settings plugin for additional configuration options.");
      f.append(createEl("br"));
      f.append(createEl("strong", {
        text: "Note: Using +, *, -, >, or # as the callout character can disrupt reading mode."
      }));
    }));
    this.plugin.settings.forEach((callout, index) => {
      buildSetting(containerEl, this.plugin, index, callout, (indexToDelete) => {
        this.plugin.settings.splice(indexToDelete, 1);
        this.plugin.saveSettings();
        this.display();
      });
    });
    buildNewCalloutSetting(containerEl, this.plugin, (callout) => {
      this.plugin.settings.push(callout);
      this.plugin.saveSettings();
      this.display();
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = [
  {
    color: "255, 214, 0",
    char: "&"
  },
  {
    color: "255, 145, 0",
    char: "?"
  },
  {
    color: "255, 23, 68",
    char: "!"
  },
  {
    color: "124, 77, 255",
    char: "~"
  },
  {
    color: "0, 184, 212",
    char: "@"
  },
  {
    color: "0, 200, 83",
    char: "$"
  },
  {
    color: "158, 158, 158",
    char: "%"
  }
];
var ListCalloutsPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.emitSettingsUpdate = (0, import_obsidian5.debounce)(() => this.dispatchUpdate(), 2e3, true);
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.buildPostProcessorConfig();
      this.addSettingTab(new ListCalloutSettings(this));
      this.emitter = new import_obsidian5.Events();
      this.registerMarkdownPostProcessor(buildPostProcessor(() => this.postProcessorConfig), 1e4);
      this.registerEditorExtension([
        calloutsConfigField.init(() => {
          return this.buildEditorConfig();
        }),
        calloutExtension
      ]);
      app.workspace.trigger("parse-style-settings");
    });
  }
  dispatchUpdate() {
    const newConfig = this.buildEditorConfig();
    app.workspace.getLeavesOfType("markdown").find((l) => {
      const view = l.view;
      const cm = view.editor.cm;
      cm == null ? void 0 : cm.dispatch({
        effects: [setConfig.of(newConfig)]
      });
    });
  }
  buildEditorConfig() {
    return {
      callouts: this.settings.reduce((record, curr) => {
        record[curr.char] = curr;
        return record;
      }, {}),
      re: new RegExp(`(^\\s*[-*+](?: \\[.\\])? |^\\s*\\d+[\\.\\)](?: \\[.\\])? )(${this.settings.map((callout) => escapeStringRegexp(callout.char)).join("|")}) `)
    };
  }
  buildPostProcessorConfig() {
    this.postProcessorConfig = {
      callouts: this.settings.reduce((record, curr) => {
        record[curr.char] = curr;
        return record;
      }, {}),
      re: new RegExp(`^(${this.settings.map((callout) => escapeStringRegexp(callout.char)).join("|")}) `)
    };
  }
  loadSettings() {
    return __async(this, null, function* () {
      const loadedSettings = yield this.loadData();
      const customCallouts = loadedSettings == null ? void 0 : loadedSettings.filter((callout) => callout.custom === true);
      const modifiedBuiltins = loadedSettings == null ? void 0 : loadedSettings.filter((callout) => callout.custom !== true);
      this.settings = DEFAULT_SETTINGS.map((s, i) => {
        return Object.assign({}, s, modifiedBuiltins ? modifiedBuiltins[i] : {});
      });
      if (customCallouts) {
        this.settings.push(...customCallouts);
      }
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.emitSettingsUpdate();
      this.buildPostProcessorConfig();
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAibm9kZV9tb2R1bGVzL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzIiwgInNyYy9leHRlbnNpb24udHMiLCAic3JjL3Bvc3RQcm9jZXNzb3IudHMiLCAic3JjL3NldHRpbmdzLnRzIiwgIm5vZGVfbW9kdWxlcy9mdXNlLmpzL2Rpc3QvZnVzZS5lc20uanMiLCAic3JjL2ljb25MaXN0LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgZXNjYXBlU3RyaW5nUmVnZXhwIGZyb20gJ2VzY2FwZS1zdHJpbmctcmVnZXhwJztcbmltcG9ydCB7IEV2ZW50cywgTWFya2Rvd25WaWV3LCBQbHVnaW4sIGRlYm91bmNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgeyBjYWxsb3V0RXh0ZW5zaW9uLCBjYWxsb3V0c0NvbmZpZ0ZpZWxkLCBzZXRDb25maWcgfSBmcm9tICcuL2V4dGVuc2lvbic7XG5pbXBvcnQgeyBidWlsZFBvc3RQcm9jZXNzb3IgfSBmcm9tICcuL3Bvc3RQcm9jZXNzb3InO1xuaW1wb3J0IHtcbiAgQ2FsbG91dCxcbiAgQ2FsbG91dENvbmZpZyxcbiAgTGlzdENhbGxvdXRTZXR0aW5ncyxcbiAgTGlzdENhbGxvdXRzU2V0dGluZ3MsXG59IGZyb20gJy4vc2V0dGluZ3MnO1xuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBMaXN0Q2FsbG91dHNTZXR0aW5ncyA9IFtcbiAge1xuICAgIGNvbG9yOiAnMjU1LCAyMTQsIDAnLFxuICAgIGNoYXI6ICcmJyxcbiAgfSxcbiAge1xuICAgIGNvbG9yOiAnMjU1LCAxNDUsIDAnLFxuICAgIGNoYXI6ICc/JyxcbiAgfSxcbiAge1xuICAgIGNvbG9yOiAnMjU1LCAyMywgNjgnLFxuICAgIGNoYXI6ICchJyxcbiAgfSxcbiAge1xuICAgIGNvbG9yOiAnMTI0LCA3NywgMjU1JyxcbiAgICBjaGFyOiAnficsXG4gIH0sXG4gIHtcbiAgICBjb2xvcjogJzAsIDE4NCwgMjEyJyxcbiAgICBjaGFyOiAnQCcsXG4gIH0sXG4gIHtcbiAgICBjb2xvcjogJzAsIDIwMCwgODMnLFxuICAgIGNoYXI6ICckJyxcbiAgfSxcbiAge1xuICAgIGNvbG9yOiAnMTU4LCAxNTgsIDE1OCcsXG4gICAgY2hhcjogJyUnLFxuICB9LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdENhbGxvdXRzUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgc2V0dGluZ3M6IExpc3RDYWxsb3V0c1NldHRpbmdzO1xuICBlbWl0dGVyOiBFdmVudHM7XG4gIHBvc3RQcm9jZXNzb3JDb25maWc6IENhbGxvdXRDb25maWc7XG5cbiAgYXN5bmMgb25sb2FkKCkge1xuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgdGhpcy5idWlsZFBvc3RQcm9jZXNzb3JDb25maWcoKTtcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IExpc3RDYWxsb3V0U2V0dGluZ3ModGhpcykpO1xuXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEV2ZW50cygpO1xuXG4gICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duUG9zdFByb2Nlc3NvcihcbiAgICAgIGJ1aWxkUG9zdFByb2Nlc3NvcigoKSA9PiB0aGlzLnBvc3RQcm9jZXNzb3JDb25maWcpLFxuICAgICAgMTAwMDBcbiAgICApO1xuXG4gICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbihbXG4gICAgICBjYWxsb3V0c0NvbmZpZ0ZpZWxkLmluaXQoKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEVkaXRvckNvbmZpZygpO1xuICAgICAgfSksXG4gICAgICBjYWxsb3V0RXh0ZW5zaW9uLFxuICAgIF0pO1xuXG4gICAgYXBwLndvcmtzcGFjZS50cmlnZ2VyKCdwYXJzZS1zdHlsZS1zZXR0aW5ncycpO1xuICB9XG5cbiAgZW1pdFNldHRpbmdzVXBkYXRlID0gZGVib3VuY2UoKCkgPT4gdGhpcy5kaXNwYXRjaFVwZGF0ZSgpLCAyMDAwLCB0cnVlKTtcblxuICBkaXNwYXRjaFVwZGF0ZSgpIHtcbiAgICBjb25zdCBuZXdDb25maWcgPSB0aGlzLmJ1aWxkRWRpdG9yQ29uZmlnKCk7XG5cbiAgICBhcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZSgnbWFya2Rvd24nKS5maW5kKChsKSA9PiB7XG4gICAgICBjb25zdCB2aWV3ID0gbC52aWV3IGFzIE1hcmtkb3duVmlldztcbiAgICAgIGNvbnN0IGNtID0gKHZpZXcuZWRpdG9yIGFzIGFueSkuY20gYXMgRWRpdG9yVmlldztcblxuICAgICAgY20/LmRpc3BhdGNoKHtcbiAgICAgICAgZWZmZWN0czogW3NldENvbmZpZy5vZihuZXdDb25maWcpXSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgYnVpbGRFZGl0b3JDb25maWcoKTogQ2FsbG91dENvbmZpZyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGxvdXRzOiB0aGlzLnNldHRpbmdzLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCBDYWxsb3V0Pj4oKHJlY29yZCwgY3VycikgPT4ge1xuICAgICAgICByZWNvcmRbY3Vyci5jaGFyXSA9IGN1cnI7XG4gICAgICAgIHJldHVybiByZWNvcmRcbiAgICAgIH0sIHt9KSxcbiAgICAgIHJlOiBuZXcgUmVnRXhwKFxuICAgICAgICBgKF5cXFxccypbLSorXSg/OiBcXFxcWy5cXFxcXSk/IHxeXFxcXHMqXFxcXGQrW1xcXFwuXFxcXCldKD86IFxcXFxbLlxcXFxdKT8gKSgke1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MubWFwKGNhbGxvdXQgPT4gZXNjYXBlU3RyaW5nUmVnZXhwKGNhbGxvdXQuY2hhcikpLmpvaW4oJ3wnKVxuICAgICAgICB9KSBgXG4gICAgICApLFxuICAgIH1cbiAgfVxuXG4gIGJ1aWxkUG9zdFByb2Nlc3NvckNvbmZpZygpIHtcbiAgICB0aGlzLnBvc3RQcm9jZXNzb3JDb25maWcgPSB7XG4gICAgICBjYWxsb3V0czogdGhpcy5zZXR0aW5ncy5yZWR1Y2U8UmVjb3JkPHN0cmluZywgQ2FsbG91dD4+KChyZWNvcmQsIGN1cnIpID0+IHtcbiAgICAgICAgcmVjb3JkW2N1cnIuY2hhcl0gPSBjdXJyO1xuICAgICAgICByZXR1cm4gcmVjb3JkXG4gICAgICB9LCB7fSksXG4gICAgICByZTogbmV3IFJlZ0V4cChcbiAgICAgICAgYF4oJHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLm1hcChjYWxsb3V0ID0+IGVzY2FwZVN0cmluZ1JlZ2V4cChjYWxsb3V0LmNoYXIpKS5qb2luKCd8JylcbiAgICAgICAgfSkgYFxuICAgICAgKSxcbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgY29uc3QgbG9hZGVkU2V0dGluZ3MgPSAoYXdhaXQgdGhpcy5sb2FkRGF0YSgpKSBhcyBDYWxsb3V0W107XG4gICAgY29uc3QgY3VzdG9tQ2FsbG91dHMgPSBsb2FkZWRTZXR0aW5ncz8uZmlsdGVyKFxuICAgICAgKGNhbGxvdXQpID0+IGNhbGxvdXQuY3VzdG9tID09PSB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBtb2RpZmllZEJ1aWx0aW5zID0gbG9hZGVkU2V0dGluZ3M/LmZpbHRlcihcbiAgICAgIChjYWxsb3V0KSA9PiBjYWxsb3V0LmN1c3RvbSAhPT0gdHJ1ZVxuICAgICk7XG5cbiAgICB0aGlzLnNldHRpbmdzID0gREVGQVVMVF9TRVRUSU5HUy5tYXAoKHMsIGkpID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzLCBtb2RpZmllZEJ1aWx0aW5zID8gbW9kaWZpZWRCdWlsdGluc1tpXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21DYWxsb3V0cykge1xuICAgICAgdGhpcy5zZXR0aW5ncy5wdXNoKC4uLmN1c3RvbUNhbGxvdXRzKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB0aGlzLmVtaXRTZXR0aW5nc1VwZGF0ZSgpO1xuICAgIHRoaXMuYnVpbGRQb3N0UHJvY2Vzc29yQ29uZmlnKCk7XG4gIH1cbn1cbiIsICJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyaW5nKSB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyBFc2NhcGUgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZyBlaXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgY2hhcmFjdGVyIHNldHMuXG5cdC8vIFVzZSBhIHNpbXBsZSBiYWNrc2xhc2ggZXNjYXBlIHdoZW4gaXRcdTIwMTlzIGFsd2F5cyB2YWxpZCwgYW5kIGEgYFxceG5uYCBlc2NhcGUgd2hlbiB0aGUgc2ltcGxlciBmb3JtIHdvdWxkIGJlIGRpc2FsbG93ZWQgYnkgVW5pY29kZSBwYXR0ZXJuc1x1MjAxOSBzdHJpY3RlciBncmFtbWFyLlxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJylcblx0XHQucmVwbGFjZSgvLS9nLCAnXFxcXHgyZCcpO1xufVxuIiwgImltcG9ydCB7IGVuc3VyZVN5bnRheFRyZWUsIHRva2VuQ2xhc3NOb2RlUHJvcCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7XG4gIEVkaXRvclN0YXRlLFxuICBSYW5nZVNldEJ1aWxkZXIsXG4gIFN0YXRlRWZmZWN0LFxuICBTdGF0ZUZpZWxkLFxufSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQge1xuICBEZWNvcmF0aW9uLFxuICBEZWNvcmF0aW9uU2V0LFxuICBFZGl0b3JWaWV3LFxuICBWaWV3UGx1Z2luLFxuICBWaWV3VXBkYXRlLFxuICBXaWRnZXRUeXBlLFxufSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHNldEljb24gfSBmcm9tICdvYnNpZGlhbic7XG5cbmltcG9ydCB7IENhbGxvdXRDb25maWcgfSBmcm9tICcuL3NldHRpbmdzJztcblxuZXhwb3J0IGNvbnN0IHNldENvbmZpZyA9IFN0YXRlRWZmZWN0LmRlZmluZTxDYWxsb3V0Q29uZmlnPigpO1xuXG5leHBvcnQgY2xhc3MgQ2FsbG91dEJhY2tncm91bmQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgdG9ET00oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNwYW4oe1xuICAgICAgY2xzOiAnbGMtbGlzdC1iZycsXG4gICAgICBhdHRyOiB7XG4gICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbiAgZXEoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENhbGxvdXRNYXJrZXIgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgY2hhcjogc3RyaW5nO1xuICBpY29uPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNoYXI6IHN0cmluZywgaWNvbj86IHN0cmluZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNoYXIgPSBjaGFyO1xuICAgIHRoaXMuaWNvbiA9IGljb247XG4gIH1cblxuICB0b0RPTSgpIHtcbiAgICByZXR1cm4gY3JlYXRlU3BhbihcbiAgICAgIHtcbiAgICAgICAgdGV4dDogdGhpcy5jaGFyLFxuICAgICAgICBjbHM6ICdsYy1saXN0LW1hcmtlcicsXG4gICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgKHMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaWNvbikge1xuICAgICAgICAgIHNldEljb24ocywgdGhpcy5pY29uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBlcSh3aWRnZXQ6IENhbGxvdXRNYXJrZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gd2lkZ2V0LmNoYXIgPT09IHRoaXMuY2hhciAmJiB3aWRnZXQuaWNvbiA9PT0gdGhpcy5pY29uO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjYWxsb3V0RGVjb3JhdGlvbiA9IChjaGFyOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcpID0+XG4gIERlY29yYXRpb24ubGluZSh7XG4gICAgYXR0cmlidXRlczoge1xuICAgICAgY2xhc3M6ICdsYy1saXN0LWNhbGxvdXQnLFxuICAgICAgc3R5bGU6IGAtLWxjLWNhbGxvdXQtY29sb3I6ICR7Y29sb3J9YCxcbiAgICAgICdkYXRhLWNhbGxvdXQnOiBjaGFyLFxuICAgIH0sXG4gIH0pO1xuXG5leHBvcnQgY29uc3QgY2FsbG91dHNDb25maWdGaWVsZCA9IFN0YXRlRmllbGQuZGVmaW5lPENhbGxvdXRDb25maWc+KHtcbiAgY3JlYXRlKCkge1xuICAgIHJldHVybiB7IGNhbGxvdXRzOiB7fSwgcmU6IG51bGwgfTtcbiAgfSxcbiAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgIGZvciAoY29uc3QgZSBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICBpZiAoZS5pcyhzZXRDb25maWcpKSB7XG4gICAgICAgIHN0YXRlID0gZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH0sXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ2FsbG91dERlY29zKHZpZXc6IEVkaXRvclZpZXcsIHN0YXRlOiBFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBjb25maWcgPSBzdGF0ZS5maWVsZChjYWxsb3V0c0NvbmZpZ0ZpZWxkKTtcbiAgaWYgKCFjb25maWc/LnJlIHx8ICF2aWV3LnZpc2libGVSYW5nZXMubGVuZ3RoKSByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuXG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyPERlY29yYXRpb24+KCk7XG4gIGNvbnN0IGxhc3RSYW5nZSA9IHZpZXcudmlzaWJsZVJhbmdlc1t2aWV3LnZpc2libGVSYW5nZXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHRyZWUgPSBlbnN1cmVTeW50YXhUcmVlKHN0YXRlLCBsYXN0UmFuZ2UudG8sIDUwKTtcbiAgY29uc3QgeyBkb2MgfSA9IHN0YXRlO1xuXG4gIGxldCBsYXN0RW5kID0gLTE7XG5cbiAgZm9yIChjb25zdCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgdHJlZS5pdGVyYXRlKHtcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIGVudGVyKHsgdHlwZSwgZnJvbSwgdG8gfSk6IGZhbHNlIHwgdm9pZCB7XG4gICAgICAgIGlmIChmcm9tIDw9IGxhc3RFbmQpIHJldHVybjtcblxuICAgICAgICBjb25zdCBwcm9wID0gdHlwZS5wcm9wKHRva2VuQ2xhc3NOb2RlUHJvcCk7XG4gICAgICAgIGlmIChwcm9wICYmIC9mb3JtYXR0aW5nLWxpc3QvLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICBjb25zdCB7IGZyb206IGxpbmVGcm9tLCB0bywgdGV4dCB9ID0gZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2goY29uZmlnLnJlKTtcbiAgICAgICAgICBjb25zdCBjYWxsb3V0ID0gbWF0Y2ggPyBjb25maWcuY2FsbG91dHNbbWF0Y2hbMl1dIDogbnVsbDtcblxuICAgICAgICAgIGxhc3RFbmQgPSB0bztcblxuICAgICAgICAgIGlmIChjYWxsb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFBvcyA9IGxpbmVGcm9tICsgbWF0Y2hbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGxpbmUgY2xhc3MgYW5kIGNhbGxvdXQgY29sb3JcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmVGcm9tLCBsaW5lRnJvbSwgY2FsbG91dERlY29yYXRpb24oY2FsbG91dC5jaGFyLCBjYWxsb3V0LmNvbG9yKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY2FsbG91dCBiYWNrZ3JvdW5kIGVsZW1lbnRcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkKFxuICAgICAgICAgICAgICBsaW5lRnJvbSxcbiAgICAgICAgICAgICAgbGluZUZyb20sXG4gICAgICAgICAgICAgIERlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiBuZXcgQ2FsbG91dEJhY2tncm91bmQoKSwgc2lkZTogLTEgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIERlY29yYXRlIHRoZSBjYWxsb3V0IG1hcmtlclxuICAgICAgICAgICAgYnVpbGRlci5hZGQoXG4gICAgICAgICAgICAgIGxhYmVsUG9zLFxuICAgICAgICAgICAgICBsYWJlbFBvcyArIGNhbGxvdXQuY2hhci5sZW5ndGgsXG4gICAgICAgICAgICAgIERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQ2FsbG91dE1hcmtlcihjYWxsb3V0LmNoYXIsIGNhbGxvdXQuaWNvbiksXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xufVxuXG5leHBvcnQgY29uc3QgY2FsbG91dEV4dGVuc2lvbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKFxuICBjbGFzcyB7XG4gICAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQ7XG5cbiAgICBjb25zdHJ1Y3Rvcih2aWV3OiBFZGl0b3JWaWV3KSB7XG4gICAgICB0aGlzLmRlY29yYXRpb25zID0gYnVpbGRDYWxsb3V0RGVjb3Modmlldywgdmlldy5zdGF0ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHVwZGF0ZTogVmlld1VwZGF0ZSkge1xuICAgICAgaWYgKFxuICAgICAgICB1cGRhdGUuZG9jQ2hhbmdlZCB8fFxuICAgICAgICB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgIHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSgodHIpID0+XG4gICAgICAgICAgdHIuZWZmZWN0cy5zb21lKChlKSA9PiBlLmlzKHNldENvbmZpZykpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gYnVpbGRDYWxsb3V0RGVjb3ModXBkYXRlLnZpZXcsIHVwZGF0ZS5zdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB7XG4gICAgZGVjb3JhdGlvbnM6ICh2KSA9PiB2LmRlY29yYXRpb25zLFxuICB9XG4pO1xuIiwgImltcG9ydCB7IE1hcmtkb3duUG9zdFByb2Nlc3Nvciwgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJztcblxuaW1wb3J0IHsgQ2FsbG91dENvbmZpZyB9IGZyb20gJy4vc2V0dGluZ3MnO1xuXG5mdW5jdGlvbiBnZXRGaXJzdFRleHROb2RlKGxpOiBIVE1MRWxlbWVudCkge1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgQXJyYXkuZnJvbShsaS5jaGlsZE5vZGVzKSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBkb2N1bWVudC5FTEVNRU5UX05PREUgJiYgKG5vZGUgYXMgSFRNTEVsZW1lbnQpLmNsYXNzTGlzdC5jb250YWlucygndGFza3MtbGlzdC10ZXh0JykpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uTm9kZSA9IChub2RlIGFzIEhUTUxFbGVtZW50KS5maXJzdEVsZW1lbnRDaGlsZFxuICAgICAgaWYgKGRlc2NyaXB0aW9uTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXNrLWRlc2NyaXB0aW9uJykpIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBkZXNjcmlwdGlvbk5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ/LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5ub2RlVHlwZSA9PT0gZG9jdW1lbnQuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gZG9jdW1lbnQuRUxFTUVOVF9OT0RFICYmXG4gICAgICAobm9kZSBhcyBIVE1MRWxlbWVudCkudGFnTmFtZSA9PT0gJ1AnXG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9kZS5maXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBkb2N1bWVudC5URVhUX05PREUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgobm9kZSBhcyBUZXh0KS5ub2RlVmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gd3JhcExpQ29udGVudChsaTogSFRNTEVsZW1lbnQpIHtcbiAgY29uc3QgdG9SZXBsYWNlOiBDaGlsZE5vZGVbXSA9IFtdO1xuICBsZXQgaW5zZXJ0QmVmb3JlID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGkuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gbGkuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSBkb2N1bWVudC5FTEVNRU5UX05PREUpIHtcbiAgICAgIGNvbnN0IGVsID0gY2hpbGQgYXMgRWxlbWVudDtcbiAgICAgIGlmIChcbiAgICAgICAgZWwuaGFzQ2xhc3MoJ2xpc3QtY29sbGFwc2UtaW5kaWNhdG9yJykgfHxcbiAgICAgICAgZWwuaGFzQ2xhc3MoJ2xpc3QtYnVsbGV0JylcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFsnVUwnLCAnT0wnXS5pbmNsdWRlcyhlbC50YWdOYW1lKSkge1xuICAgICAgICBpbnNlcnRCZWZvcmUgPSBjaGlsZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9SZXBsYWNlLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZVNwYW4oeyBjbHM6ICdsYy1saS13cmFwcGVyJyB9KTtcblxuICB0b1JlcGxhY2UuZm9yRWFjaCgobm9kZSkgPT4gd3JhcHBlci5hcHBlbmQobm9kZSkpO1xuXG4gIGlmIChpbnNlcnRCZWZvcmUpIHtcbiAgICBpbnNlcnRCZWZvcmUuYmVmb3JlKHdyYXBwZXIpO1xuICB9IGVsc2Uge1xuICAgIGxpLmFwcGVuZCh3cmFwcGVyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQb3N0UHJvY2Vzc29yKFxuICBnZXRDb25maWc6ICgpID0+IENhbGxvdXRDb25maWdcbik6IE1hcmtkb3duUG9zdFByb2Nlc3NvciB7XG4gIHJldHVybiBhc3luYyAoZWwsIGN0eDogYW55KSA9PiB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKCk7XG5cbiAgICBpZiAoY3R4LnByb21pc2VzPy5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGN0eC5wcm9taXNlcyk7XG4gICAgfVxuXG4gICAgZWwuZmluZEFsbCgnbGknKS5mb3JFYWNoKChsaSkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IGdldEZpcnN0VGV4dE5vZGUobGkpO1xuICAgICAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHRleHQgPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgaWYgKCF0ZXh0KSByZXR1cm47XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gdGV4dC5tYXRjaChjb25maWcucmUpO1xuICAgICAgY29uc3QgY2FsbG91dCA9IG1hdGNoID8gY29uZmlnLmNhbGxvdXRzW21hdGNoWzFdXSA6IG51bGw7XG5cbiAgICAgIGlmIChjYWxsb3V0KSB7XG4gICAgICAgIGxpLmFkZENsYXNzKCdsYy1saXN0LWNhbGxvdXQnKTtcbiAgICAgICAgbGkuc2V0QXR0cmlidXRlKCdkYXRhLWNhbGxvdXQnLCBjYWxsb3V0LmNoYXIpO1xuICAgICAgICBsaS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1sYy1jYWxsb3V0LWNvbG9yJywgY2FsbG91dC5jb2xvcik7XG5cbiAgICAgICAgbm9kZS5yZXBsYWNlV2l0aChcbiAgICAgICAgICBjcmVhdGVGcmFnbWVudCgoZikgPT4ge1xuICAgICAgICAgICAgZi5hcHBlbmQoXG4gICAgICAgICAgICAgIGNyZWF0ZVNwYW4oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY2xzOiAnbGMtbGlzdC1tYXJrZXInLFxuICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dC5zbGljZSgwLCBjYWxsb3V0LmNoYXIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbG91dC5pY29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEljb24oc3BhbiwgY2FsbG91dC5pY29uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmLmFwcGVuZCh0ZXh0LnNsaWNlKGNhbGxvdXQuY2hhci5sZW5ndGgpKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHdyYXBMaUNvbnRlbnQobGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuIiwgImltcG9ydCB7XG4gIEJ1dHRvbkNvbXBvbmVudCxcbiAgQ29sb3JDb21wb25lbnQsXG4gIFBsYXRmb3JtLFxuICBQbHVnaW5TZXR0aW5nVGFiLFxuICBTZXR0aW5nLFxuICBUZXh0Q29tcG9uZW50LFxuICBkZWJvdW5jZSxcbiAgZ2V0SWNvbklkcyxcbiAgc2V0SWNvbixcbn0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgeyBpY29uTGlzdCBhcyBpY29ucyB9IGZyb20gJy4vaWNvbkxpc3QnO1xuaW1wb3J0IExpc3RDYWxsb3V0c1BsdWdpbiBmcm9tICcuL21haW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGxvdXQge1xuICBjaGFyOiBzdHJpbmc7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGljb24/OiBzdHJpbmc7XG4gIGN1c3RvbT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbG91dENvbmZpZyB7XG4gIGNhbGxvdXRzOiBSZWNvcmQ8c3RyaW5nLCBDYWxsb3V0PjtcbiAgcmU6IFJlZ0V4cDtcbn1cblxuZXhwb3J0IHR5cGUgTGlzdENhbGxvdXRzU2V0dGluZ3MgPSBDYWxsb3V0W107XG5cbi8vIEJ1aWxkIGEgc3RhdGljIENNNiBsaXN0IGxpbmUgd2l0aCBjYWxsb3V0IG1hcmt1cCBhcHBsaWVkXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTZXR0aW5nQ2FsbG91dChyb290OiBIVE1MRWxlbWVudCwgY2FsbG91dDogQ2FsbG91dCkge1xuICByb290LmVtcHR5KCk7XG4gIHJvb3QuY3JlYXRlRGl2KFxuICAgIHtcbiAgICAgIGNsczogJ21hcmtkb3duLXNvdXJjZS12aWV3IGNtLXMtb2JzaWRpYW4gbW9kLWNtNiBpcy1yZWFkYWJsZS1saW5lLXdpZHRoIGlzLWxpdmUtcHJldmlldycsXG4gICAgfSxcbiAgICAobW9ja1NyY1ZpZXcpID0+IHtcbiAgICAgIG1vY2tTcmNWaWV3LmNyZWF0ZURpdihcbiAgICAgICAge1xuICAgICAgICAgIGNsczogJ0h5cGVyTUQtbGlzdC1saW5lIEh5cGVyTUQtbGlzdC1saW5lLTEgbGMtbGlzdC1jYWxsb3V0IGNtLWxpbmUnLFxuICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgIHN0eWxlOiBgdGV4dC1pbmRlbnQ6IC04cHg7IHBhZGRpbmctbGVmdDogMTJweDsgLS1sYy1jYWxsb3V0LWNvbG9yOiAke2NhbGxvdXQuY29sb3J9YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICAobW9ja0xpc3RMaW5lKSA9PiB7XG4gICAgICAgICAgbW9ja0xpc3RMaW5lLmNyZWF0ZVNwYW4oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsczogJ2NtLWZvcm1hdHRpbmcgY20tZm9ybWF0dGluZy1saXN0IGNtLWZvcm1hdHRpbmctbGlzdC11bCBjbS1saXN0LTEnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHNwYW4uY3JlYXRlU3Bhbih7IGNsczogJ2xpc3QtYnVsbGV0JywgdGV4dDogJy0nIH0pO1xuICAgICAgICAgICAgICBzcGFuLmFwcGVuZFRleHQoJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIG1vY2tMaXN0TGluZS5jcmVhdGVTcGFuKHsgY2xzOiAnbGMtbGlzdC1iZycgfSk7XG4gICAgICAgICAgbW9ja0xpc3RMaW5lLmNyZWF0ZVNwYW4oeyBjbHM6ICdsYy1saXN0LW1hcmtlcicgfSwgKHNwYW4pID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsb3V0Lmljb24pIHtcbiAgICAgICAgICAgICAgc2V0SWNvbihzcGFuLCBjYWxsb3V0Lmljb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRUZXh0KGNhbGxvdXQuY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbW9ja0xpc3RMaW5lLmNyZWF0ZVNwYW4oe1xuICAgICAgICAgICAgY2xzOiAnY20tbGlzdC0xJyxcbiAgICAgICAgICAgIHRleHQ6ICcgU2VkIGV1IG5pc2wgcmhvbmN1cywgY29uc2VjdGV0dXIgbWkgcXVpcywgc2NlbGVyaXNxdWUgZW5pbS4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoSWNvbk1lbnUoXG4gIGJ0bjogQnV0dG9uQ29tcG9uZW50LFxuICBvblNlbGVjdDogKGljb246IG51bGwgfCBzdHJpbmcpID0+IHZvaWRcbikge1xuICBsZXQgbWVudVJlZjogSFRNTERpdkVsZW1lbnQgPSBudWxsO1xuICBjb25zdCBidG5FbCA9IGJ0bi5idXR0b25FbDtcblxuICBidG4ub25DbGljaygoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBzY3JvbGxQYXJlbnQgPSBidG5FbC5jbG9zZXN0KCcudmVydGljYWwtdGFiLWNvbnRlbnQnKTtcbiAgICBjb25zdCBkZXN0cm95RXZlbnRIYW5kbGVycyA9ICgpID0+IHtcbiAgICAgIGJ0bkVsLndpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrT3V0c2lkZSk7XG4gICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsKTtcbiAgICB9O1xuICAgIGNvbnN0IGNsaWNrT3V0c2lkZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAobWVudVJlZikge1xuICAgICAgICBpZiAoIW1lbnVSZWYuY29udGFpbnMoZS50YXJnZXROb2RlKSkge1xuICAgICAgICAgIG1lbnVSZWYuZGV0YWNoKCk7XG4gICAgICAgICAgbWVudVJlZiA9IG51bGw7XG4gICAgICAgICAgZGVzdHJveUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdHJveUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgY2FsY01lbnVQb3MgPSAoKSA9PiB7XG4gICAgICBsZXQgcG9zID0gYHRvcDogJHtcbiAgICAgICAgYnRuRWwub2Zmc2V0VG9wICsgYnRuRWwub2Zmc2V0SGVpZ2h0ICsgMiAtIHNjcm9sbFBhcmVudC5zY3JvbGxUb3BcbiAgICAgIH1weDtgO1xuICAgICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKSB7XG4gICAgICAgIHBvcyArPSBgIHJpZ2h0OiAke1xuICAgICAgICAgIGJ0bkVsLm9mZnNldFBhcmVudC5jbGllbnRXaWR0aCAtXG4gICAgICAgICAgKGJ0bkVsLm9mZnNldExlZnQgKyBidG5FbC5vZmZzZXRXaWR0aClcbiAgICAgICAgfXB4O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgKz0gYCBsZWZ0OiAke2J0bkVsLm9mZnNldExlZnR9cHg7YDtcbiAgICAgIH1cbiAgICAgIG1lbnVSZWYuc3R5bGUuY3NzVGV4dCA9IHBvcztcbiAgICB9O1xuXG4gICAgY29uc3Qgc2Nyb2xsID0gKCkgPT4ge1xuICAgICAgaWYgKG1lbnVSZWYpIHtcbiAgICAgICAgY2FsY01lbnVQb3MoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3Ryb3lFdmVudEhhbmRsZXJzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChtZW51UmVmKSB7XG4gICAgICBkZXN0cm95RXZlbnRIYW5kbGVycygpO1xuICAgICAgbWVudVJlZi5kZXRhY2goKTtcbiAgICAgIG1lbnVSZWYgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNyZWF0ZURpdignbGMtbWVudScsIChtZW51KSA9PiB7XG4gICAgICBtZW51UmVmID0gbWVudTtcbiAgICAgIGJ0bkVsLmFmdGVyKG1lbnVSZWYpO1xuICAgICAgY2FsY01lbnVQb3MoKTtcblxuICAgICAgY29uc3QgaWNvbkVsczogUmVjb3JkPHN0cmluZywgSFRNTERpdkVsZW1lbnQ+ID0ge307XG5cbiAgICAgIG1lbnUuY3JlYXRlRGl2KCdsYy1tZW51LXNlYXJjaCcsIChlbCkgPT4ge1xuICAgICAgICBlbC5jcmVhdGVFbChcbiAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1NlYXJjaC4uLicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVXaW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBkZWJvdW5jZShcbiAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGljb25zLnNlYXJjaChpbnB1dC52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBnZXRJY29uSWRzKCkuZm9yRWFjaCgoaWNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpY29uTGlzdC5hcHBlbmQoaWNvbkVsc1tpY29uXSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpY29uTGlzdC5lbXB0eSgpO1xuXG4gICAgICAgICAgICAgICAgcmVzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIGljb25MaXN0LmFwcGVuZChpY29uRWxzW3IuaXRlbS5pZF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAyNTAsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBpY29uTGlzdCA9IG1lbnUuY3JlYXRlRGl2KCdsYy1tZW51LWljb25zJywgKGVsKSA9PiB7XG4gICAgICAgIC8vIE1lbnVcbiAgICAgICAgZ2V0SWNvbklkcygpLmZvckVhY2goKGljb24pID0+IHtcbiAgICAgICAgICBlbC5jcmVhdGVEaXYoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsczogJ2NsaWNrYWJsZS1pY29uJyxcbiAgICAgICAgICAgICAgYXR0cjoge1xuICAgICAgICAgICAgICAgICdkYXRhLWljb24nOiBpY29uLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgIGljb25FbHNbaWNvbl0gPSBpdGVtO1xuICAgICAgICAgICAgICBzZXRJY29uKGl0ZW0sIGljb24pO1xuICAgICAgICAgICAgICBpdGVtLm9uQ2xpY2tFdmVudCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgYnRuLmJ1dHRvbkVsLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgYnRuLnNldEljb24oaWNvbik7XG4gICAgICAgICAgICAgICAgb25TZWxlY3QoaWNvbik7XG4gICAgICAgICAgICAgICAgZGVzdHJveUV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICBtZW51UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIG1lbnVSZWYgPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYnRuRWwud2luLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYnRuRWwud2luLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tPdXRzaWRlKTtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGwpO1xuICAgIH0sIDEwKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNldHRpbmcoXG4gIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcbiAgcGx1Z2luOiBMaXN0Q2FsbG91dHNQbHVnaW4sXG4gIGluZGV4OiBudW1iZXIsXG4gIGNhbGxvdXQ6IENhbGxvdXQsXG4gIG9uRGVsZXRlOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZFxuKSB7XG4gIGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ2xjLXNldHRpbmcnIH0sIChlbCkgPT4ge1xuICAgIGNvbnN0IGNhbGxvdXRDb250YWluZXIgPSBlbC5jcmVhdGVEaXYoeyBjbHM6ICdsYy1jYWxsb3V0LWNvbnRhaW5lcicgfSk7XG5cbiAgICBidWlsZFNldHRpbmdDYWxsb3V0KGNhbGxvdXRDb250YWluZXIsIGNhbGxvdXQpO1xuXG4gICAgZWwuY3JlYXRlRGl2KHsgY2xzOiAnbGMtaW5wdXQtY29udGFpbmVyJyB9LCAoaW5wdXRDb250YWluZXIpID0+IHtcbiAgICAgIC8vIENoYXJhY3RlciBpbnB1dFxuICAgICAgbmV3IFRleHRDb21wb25lbnQoaW5wdXRDb250YWluZXIpXG4gICAgICAgIC5zZXRWYWx1ZShjYWxsb3V0LmNoYXIpXG4gICAgICAgIC5vbkNoYW5nZSgodmFsdWUpID0+IHtcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgICBwbHVnaW4uc2V0dGluZ3NbaW5kZXhdLmNoYXIgPSB2YWx1ZTtcbiAgICAgICAgICBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cbiAgICAgICAgICBidWlsZFNldHRpbmdDYWxsb3V0KGNhbGxvdXRDb250YWluZXIsIHBsdWdpbi5zZXR0aW5nc1tpbmRleF0pO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gSWNvbiBzZWxlY3QgbWVudVxuICAgICAgY29uc3QgaWNvbkJ0biA9IG5ldyBCdXR0b25Db21wb25lbnQoaW5wdXRDb250YWluZXIpLnRoZW4oKGJ0bikgPT4ge1xuICAgICAgICBpZiAoY2FsbG91dC5pY29uKSB7XG4gICAgICAgICAgYnRuLnNldEljb24oY2FsbG91dC5pY29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidG4uc2V0QnV0dG9uVGV4dCgnU2V0IEljb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGFjaEljb25NZW51KGJ0biwgKGljb24pID0+IHtcbiAgICAgICAgICBpZiAoaWNvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgcGx1Z2luLnNldHRpbmdzW2luZGV4XS5pY29uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbHVnaW4uc2V0dGluZ3NbaW5kZXhdLmljb24gPSBpY29uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICBidWlsZFNldHRpbmdDYWxsb3V0KGNhbGxvdXRDb250YWluZXIsIHBsdWdpbi5zZXR0aW5nc1tpbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXcgQnV0dG9uQ29tcG9uZW50KGlucHV0Q29udGFpbmVyKS50aGVuKChidG4pID0+IHtcbiAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoJ0NsZWFyIEljb24nKTtcbiAgICAgICAgYnRuLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBwbHVnaW4uc2V0dGluZ3NbaW5kZXhdLmljb247XG4gICAgICAgICAgaWNvbkJ0bi5idXR0b25FbC5lbXB0eSgpO1xuICAgICAgICAgIGljb25CdG4uc2V0QnV0dG9uVGV4dCgnU2V0IEljb24nKTtcbiAgICAgICAgICBwbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgYnVpbGRTZXR0aW5nQ2FsbG91dChjYWxsb3V0Q29udGFpbmVyLCBwbHVnaW4uc2V0dGluZ3NbaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQ29sb3Igc2VsZWN0aW9uLlxuICAgICAgaWYgKGNhbGxvdXQuY3VzdG9tKSB7XG4gICAgICAgIGNvbnN0IFtyLCBnLCBiXSA9IGNhbGxvdXQuY29sb3JcbiAgICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAgIC5tYXAoKHYpID0+IHBhcnNlSW50KHYudHJpbSgpLCAxMCkpO1xuXG4gICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yQ29tcG9uZW50KGlucHV0Q29udGFpbmVyKVxuICAgICAgICAgIC5zZXRWYWx1ZVJnYih7IHIsIGcsIGIgfSlcbiAgICAgICAgICAub25DaGFuZ2UoKF92YWx1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByLCBnLCBiIH0gPSBjb2xvci5nZXRWYWx1ZVJnYigpO1xuICAgICAgICAgICAgcGx1Z2luLnNldHRpbmdzW2luZGV4XS5jb2xvciA9IGAke3J9LCAke2d9LCAke2J9YDtcblxuICAgICAgICAgICAgcGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgYnVpbGRTZXR0aW5nQ2FsbG91dChjYWxsb3V0Q29udGFpbmVyLCBwbHVnaW4uc2V0dGluZ3NbaW5kZXhdKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVsZXRlIGJ1dHRvbi5cbiAgICAgIGlmIChjYWxsb3V0LmN1c3RvbSkge1xuICAgICAgICBjb25zdCByaWdodEFsaWduID0gaW5wdXRDb250YWluZXIuY3JlYXRlRGl2KHtcbiAgICAgICAgICBjbHM6ICdsYy1pbnB1dC1yaWdodC1hbGlnbicsXG4gICAgICAgIH0pO1xuICAgICAgICBuZXcgQnV0dG9uQ29tcG9uZW50KHJpZ2h0QWxpZ24pXG4gICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0RlbGV0ZScpXG4gICAgICAgICAgLnNldFdhcm5pbmcoKVxuICAgICAgICAgIC5vbkNsaWNrKChfZSkgPT4ge1xuICAgICAgICAgICAgb25EZWxldGUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGROZXdDYWxsb3V0U2V0dGluZyhcbiAgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LFxuICBwbHVnaW46IExpc3RDYWxsb3V0c1BsdWdpbixcbiAgb25TdWJtaXQ6IChjYWxsb3V0OiBDYWxsb3V0KSA9PiB2b2lkXG4pIHtcbiAgY29uc3QgY2FsbG91dDogQ2FsbG91dCA9IHtcbiAgICBjaGFyOiAnJyxcbiAgICBjb2xvcjogJzE1OCwgMTU4LCAxNTgnLFxuICAgIGljb246IG51bGwsXG4gICAgY3VzdG9tOiB0cnVlLFxuICB9O1xuXG4gIGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ2xjLXNldHRpbmcnIH0sIChzZXR0aW5nQ29udGFpbmVyKSA9PiB7XG4gICAgc2V0dGluZ0NvbnRhaW5lci5jcmVhdGVEaXYoeyBjbHM6ICdzZXR0aW5nLWl0ZW0tbmFtZScgfSwgKGUpID0+XG4gICAgICBlLnNldFRleHQoJ0NyZWF0ZSBhIG5ldyBDYWxsb3V0JylcbiAgICApO1xuICAgIHNldHRpbmdDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnc2V0dGluZy1pdGVtLWRlc2NyaXB0aW9uJyB9LCAoZSkgPT5cbiAgICAgIGUuc2V0VGV4dCgnQ3JlYXRlIGFkZGl0aW9uYWwgbGlzdCBjYWxsb3V0IHN0eWxlcy4nKVxuICAgICk7XG5cbiAgICAvLyBQcmV2aWV3LlxuICAgIGNvbnN0IGNhbGxvdXRDb250YWluZXIgPSBzZXR0aW5nQ29udGFpbmVyLmNyZWF0ZURpdih7XG4gICAgICBjbHM6ICdsYy1jYWxsb3V0LWNvbnRhaW5lcicsXG4gICAgfSk7XG5cbiAgICAvLyBDYWxsb3V0IGNoYXJhY3Rlci5cbiAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IHNldHRpbmdDb250YWluZXIuY3JlYXRlRGl2KHtcbiAgICAgIGNsczogJ2xjLWlucHV0LWNvbnRhaW5lcicsXG4gICAgfSk7XG5cbiAgICBjb25zdCBjaGFyID0gbmV3IFRleHRDb21wb25lbnQoaW5wdXRDb250YWluZXIpXG4gICAgICAuc2V0VmFsdWUoJycpXG4gICAgICAuc2V0UGxhY2Vob2xkZXIoJy4uLicpXG4gICAgICAub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNhbGxvdXQuY2hhciA9IHZhbHVlO1xuICAgICAgICByZWRyYXcoKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gQ2FsbG91dCBpY29uLlxuICAgIGNvbnN0IGljb24gPSBuZXcgQnV0dG9uQ29tcG9uZW50KGlucHV0Q29udGFpbmVyKS5zZXRCdXR0b25UZXh0KCdTZXQgSWNvbicpO1xuXG4gICAgYXR0YWNoSWNvbk1lbnUoaWNvbiwgKGljb24pID0+IHtcbiAgICAgIGlmIChpY29uID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGNhbGxvdXQuaWNvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxvdXQuaWNvbiA9IGljb247XG4gICAgICB9XG4gICAgICByZWRyYXcoKTtcbiAgICB9KTtcblxuICAgIC8vIENhbGxvdXQgY29sb3IuXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3JDb21wb25lbnQoaW5wdXRDb250YWluZXIpXG4gICAgICAuc2V0VmFsdWVSZ2IoeyByOiAxMjcsIGc6IDEyNywgYjogMTI3IH0pXG4gICAgICAub25DaGFuZ2UoKF92YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHIsIGcsIGIgfSA9IGNvbG9yLmdldFZhbHVlUmdiKCk7XG4gICAgICAgIGNhbGxvdXQuY29sb3IgPSBgJHtyfSwgJHtnfSwgJHtifWA7XG4gICAgICAgIHJlZHJhdygpO1xuICAgICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgYnV0dG9uLlxuICAgIGNvbnN0IHJpZ2h0QWxpZ24gPSBpbnB1dENvbnRhaW5lci5jcmVhdGVEaXYoe1xuICAgICAgY2xzOiAnbGMtaW5wdXQtcmlnaHQtYWxpZ24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHN1Ym1pdCA9IG5ldyBCdXR0b25Db21wb25lbnQocmlnaHRBbGlnbilcbiAgICAgIC5zZXRCdXR0b25UZXh0KCdDcmVhdGUnKVxuICAgICAgLnNldERpc2FibGVkKHRydWUpXG4gICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgIG9uU3VibWl0KGNhbGxvdXQpO1xuICAgICAgfSk7XG5cbiAgICAvLyBSZWRyYXcgY2FsbG91dC9zZXR0aW5ncy5cbiAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgICBidWlsZFNldHRpbmdDYWxsb3V0KGNhbGxvdXRDb250YWluZXIsIGNhbGxvdXQpO1xuXG4gICAgICBjb25zdCBoYXNOb0NoYXJhY3RlciA9IGNhbGxvdXQuY2hhci5sZW5ndGggPT09IDA7XG4gICAgICBjb25zdCBoYXNDb25mbGljdGluZ0NoYXJhY3RlciA9XG4gICAgICAgIHBsdWdpbi5zZXR0aW5ncy5maW5kKChjKSA9PiBjLmNoYXIgPT09IGNoYXIuZ2V0VmFsdWUoKSkgIT09IHVuZGVmaW5lZDtcblxuICAgICAgc3VibWl0LnNldERpc2FibGVkKGhhc05vQ2hhcmFjdGVyIHx8IGhhc0NvbmZsaWN0aW5nQ2hhcmFjdGVyKTtcbiAgICB9XG5cbiAgICByZWRyYXcoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0Q2FsbG91dFNldHRpbmdzIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIHBsdWdpbjogTGlzdENhbGxvdXRzUGx1Z2luO1xuXG4gIGNvbnN0cnVjdG9yKHBsdWdpbjogTGlzdENhbGxvdXRzUGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXREZXNjKFxuICAgICAgY3JlYXRlRnJhZ21lbnQoKGYpID0+IHtcbiAgICAgICAgZi5hcHBlbmRUZXh0KFxuICAgICAgICAgICdTZWUgdGhlIFN0eWxlIFNldHRpbmdzIHBsdWdpbiBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuJ1xuICAgICAgICApO1xuICAgICAgICBmLmFwcGVuZChjcmVhdGVFbCgnYnInKSk7XG4gICAgICAgIGYuYXBwZW5kKFxuICAgICAgICAgIGNyZWF0ZUVsKCdzdHJvbmcnLCB7XG4gICAgICAgICAgICB0ZXh0OiAnTm90ZTogVXNpbmcgKywgKiwgLSwgPiwgb3IgIyBhcyB0aGUgY2FsbG91dCBjaGFyYWN0ZXIgY2FuIGRpc3J1cHQgcmVhZGluZyBtb2RlLicsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmZvckVhY2goKGNhbGxvdXQsIGluZGV4KSA9PiB7XG4gICAgICBidWlsZFNldHRpbmcoXG4gICAgICAgIGNvbnRhaW5lckVsLFxuICAgICAgICB0aGlzLnBsdWdpbixcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGNhbGxvdXQsXG4gICAgICAgIChpbmRleFRvRGVsZXRlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpO1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXG4gICAgICAgICAgLy8gUmUtZHJhdy5cbiAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGJ1aWxkTmV3Q2FsbG91dFNldHRpbmcoY29udGFpbmVyRWwsIHRoaXMucGx1Z2luLCAoY2FsbG91dCkgPT4ge1xuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHVzaChjYWxsb3V0KTtcbiAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXG4gICAgICAvLyBSZS1kcmF3LlxuICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsICIvKipcbiAqIEZ1c2UuanMgdjYuNi4yIC0gTGlnaHR3ZWlnaHQgZnV6enktc2VhcmNoIChodHRwOi8vZnVzZWpzLmlvKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMiBLaXJvIFJpc2sgKGh0dHA6Ly9raXJvLm1lKVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC4gQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wXG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXlcbiAgICA/IGdldFRhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsdWUpXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2Jhc2VUb1N0cmluZy5qc1xuY29uc3QgSU5GSU5JVFkgPSAxIC8gMDtcbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvaXNCb29sZWFuLmpzXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gdHJ1ZSB8fFxuICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gJ1tvYmplY3QgQm9vbGVhbl0nKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbi8vIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsodmFsdWUpIHtcbiAgcmV0dXJuICF2YWx1ZS50cmltKCkubGVuZ3RoXG59XG5cbi8vIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2dldFRhZy5qc1xuZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgPyB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICdbb2JqZWN0IFVuZGVmaW5lZF0nXG4gICAgICA6ICdbb2JqZWN0IE51bGxdJ1xuICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxufVxuXG5jb25zdCBFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUgPSAnRXh0ZW5kZWQgc2VhcmNoIGlzIG5vdCBhdmFpbGFibGUnO1xuXG5jb25zdCBJTkNPUlJFQ1RfSU5ERVhfVFlQRSA9IFwiSW5jb3JyZWN0ICdpbmRleCcgdHlwZVwiO1xuXG5jb25zdCBMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkgPSAoa2V5KSA9PlxuICBgSW52YWxpZCB2YWx1ZSBmb3Iga2V5ICR7a2V5fWA7XG5cbmNvbnN0IFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRSA9IChtYXgpID0+XG4gIGBQYXR0ZXJuIGxlbmd0aCBleGNlZWRzIG1heCBvZiAke21heH0uYDtcblxuY29uc3QgTUlTU0lOR19LRVlfUFJPUEVSVFkgPSAobmFtZSkgPT4gYE1pc3NpbmcgJHtuYW1lfSBwcm9wZXJ0eSBpbiBrZXlgO1xuXG5jb25zdCBJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUgPSAoa2V5KSA9PlxuICBgUHJvcGVydHkgJ3dlaWdodCcgaW4ga2V5ICcke2tleX0nIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyYDtcblxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY2xhc3MgS2V5U3RvcmUge1xuICBjb25zdHJ1Y3RvcihrZXlzKSB7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX2tleU1hcCA9IHt9O1xuXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBsZXQgb2JqID0gY3JlYXRlS2V5KGtleSk7XG5cbiAgICAgIHRvdGFsV2VpZ2h0ICs9IG9iai53ZWlnaHQ7XG5cbiAgICAgIHRoaXMuX2tleXMucHVzaChvYmopO1xuICAgICAgdGhpcy5fa2V5TWFwW29iai5pZF0gPSBvYmo7XG5cbiAgICAgIHRvdGFsV2VpZ2h0ICs9IG9iai53ZWlnaHQ7XG4gICAgfSk7XG5cbiAgICAvLyBOb3JtYWxpemUgd2VpZ2h0cyBzbyB0aGF0IHRoZWlyIHN1bSBpcyBlcXVhbCB0byAxXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGtleS53ZWlnaHQgLz0gdG90YWxXZWlnaHQ7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KGtleUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleU1hcFtrZXlJZF1cbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9rZXlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgbGV0IHBhdGggPSBudWxsO1xuICBsZXQgaWQgPSBudWxsO1xuICBsZXQgc3JjID0gbnVsbDtcbiAgbGV0IHdlaWdodCA9IDE7XG4gIGxldCBnZXRGbiA9IG51bGw7XG5cbiAgaWYgKGlzU3RyaW5nKGtleSkgfHwgaXNBcnJheShrZXkpKSB7XG4gICAgc3JjID0ga2V5O1xuICAgIHBhdGggPSBjcmVhdGVLZXlQYXRoKGtleSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChrZXkpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaGFzT3duLmNhbGwoa2V5LCAnbmFtZScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19LRVlfUFJPUEVSVFkoJ25hbWUnKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0ga2V5Lm5hbWU7XG4gICAgc3JjID0gbmFtZTtcblxuICAgIGlmIChoYXNPd24uY2FsbChrZXksICd3ZWlnaHQnKSkge1xuICAgICAgd2VpZ2h0ID0ga2V5LndlaWdodDtcblxuICAgICAgaWYgKHdlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUobmFtZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgobmFtZSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChuYW1lKTtcbiAgICBnZXRGbiA9IGtleS5nZXRGbjtcbiAgfVxuXG4gIHJldHVybiB7IHBhdGgsIGlkLCB3ZWlnaHQsIHNyYywgZ2V0Rm4gfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlQYXRoKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5IDoga2V5LnNwbGl0KCcuJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5SWQoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkuam9pbignLicpIDoga2V5XG59XG5cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgbGV0IGxpc3QgPSBbXTtcbiAgbGV0IGFyciA9IGZhbHNlO1xuXG4gIGNvbnN0IGRlZXBHZXQgPSAob2JqLCBwYXRoLCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG9iaikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXBhdGhbaW5kZXhdKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhdGggbGVmdCwgd2UndmUgYXJyaXZlZCBhdCB0aGUgb2JqZWN0IHdlIGNhcmUgYWJvdXQuXG4gICAgICBsaXN0LnB1c2gob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGtleSA9IHBhdGhbaW5kZXhdO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBsYXN0IHZhbHVlIGluIHRoZSBwYXRoLCBhbmQgaWYgaXQncyBhIHN0cmluZy9udW1iZXIvYm9vbCxcbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgaWYgKFxuICAgICAgICBpbmRleCA9PT0gcGF0aC5sZW5ndGggLSAxICYmXG4gICAgICAgIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNOdW1iZXIodmFsdWUpIHx8IGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgICApIHtcbiAgICAgICAgbGlzdC5wdXNoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFyciA9IHRydWU7XG4gICAgICAgIC8vIFNlYXJjaCBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBkZWVwR2V0KHZhbHVlW2ldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFuIG9iamVjdC4gUmVjdXJzZSBmdXJ0aGVyLlxuICAgICAgICBkZWVwR2V0KHZhbHVlLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2luY2UgcGF0aCB1c2VkIHRvIGJlIGEgc3RyaW5nKVxuICBkZWVwR2V0KG9iaiwgaXNTdHJpbmcocGF0aCkgPyBwYXRoLnNwbGl0KCcuJykgOiBwYXRoLCAwKTtcblxuICByZXR1cm4gYXJyID8gbGlzdCA6IGxpc3RbMF1cbn1cblxuY29uc3QgTWF0Y2hPcHRpb25zID0ge1xuICAvLyBXaGV0aGVyIHRoZSBtYXRjaGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gV2hlbiBgdHJ1ZWAsIGVhY2ggcmVjb3JkIGluIHRoZSByZXN1bHRcbiAgLy8gc2V0IHdpbGwgaW5jbHVkZSB0aGUgaW5kaWNlcyBvZiB0aGUgbWF0Y2hlZCBjaGFyYWN0ZXJzLlxuICAvLyBUaGVzZSBjYW4gY29uc2VxdWVudGx5IGJlIHVzZWQgZm9yIGhpZ2hsaWdodGluZyBwdXJwb3Nlcy5cbiAgaW5jbHVkZU1hdGNoZXM6IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgLy8gYSBwZXJmZWN0IG1hdGNoIGhhcyBhbHJlYWR5IGJlZW4gbG9jYXRlZCBpbiB0aGUgc3RyaW5nLlxuICBmaW5kQWxsTWF0Y2hlczogZmFsc2UsXG4gIC8vIE1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIG1hdGNoZWQgYmVmb3JlIGEgcmVzdWx0IGlzIGNvbnNpZGVyZWQgYSBtYXRjaFxuICBtaW5NYXRjaENoYXJMZW5ndGg6IDFcbn07XG5cbmNvbnN0IEJhc2ljT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBhbGdvcml0aG0gY29udGludWVzIHNlYXJjaGluZyB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCBldmVuIGlmIGEgcGVyZmVjdFxuICAvLyBtYXRjaCBpcyBmb3VuZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc2FtZSBpbnB1dC5cbiAgaXNDYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgLy8gV2hlbiB0cnVlLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICBpbmNsdWRlU2NvcmU6IGZhbHNlLFxuICAvLyBMaXN0IG9mIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHNlYXJjaGVkLiBUaGlzIGFsc28gc3VwcG9ydHMgbmVzdGVkIHByb3BlcnRpZXMuXG4gIGtleXM6IFtdLFxuICAvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIHJlc3VsdCBsaXN0LCBieSBzY29yZVxuICBzaG91bGRTb3J0OiB0cnVlLFxuICAvLyBEZWZhdWx0IHNvcnQgZnVuY3Rpb246IHNvcnQgYnkgYXNjZW5kaW5nIHNjb3JlLCBhc2NlbmRpbmcgaW5kZXhcbiAgc29ydEZuOiAoYSwgYikgPT5cbiAgICBhLnNjb3JlID09PSBiLnNjb3JlID8gKGEuaWR4IDwgYi5pZHggPyAtMSA6IDEpIDogYS5zY29yZSA8IGIuc2NvcmUgPyAtMSA6IDFcbn07XG5cbmNvbnN0IEZ1enp5T3B0aW9ucyA9IHtcbiAgLy8gQXBwcm94aW1hdGVseSB3aGVyZSBpbiB0aGUgdGV4dCBpcyB0aGUgcGF0dGVybiBleHBlY3RlZCB0byBiZSBmb3VuZD9cbiAgbG9jYXRpb246IDAsXG4gIC8vIEF0IHdoYXQgcG9pbnQgZG9lcyB0aGUgbWF0Y2ggYWxnb3JpdGhtIGdpdmUgdXAuIEEgdGhyZXNob2xkIG9mICcwLjAnIHJlcXVpcmVzIGEgcGVyZmVjdCBtYXRjaFxuICAvLyAob2YgYm90aCBsZXR0ZXJzIGFuZCBsb2NhdGlvbiksIGEgdGhyZXNob2xkIG9mICcxLjAnIHdvdWxkIG1hdGNoIGFueXRoaW5nLlxuICB0aHJlc2hvbGQ6IDAuNixcbiAgLy8gRGV0ZXJtaW5lcyBob3cgY2xvc2UgdGhlIG1hdGNoIG11c3QgYmUgdG8gdGhlIGZ1enp5IGxvY2F0aW9uIChzcGVjaWZpZWQgYWJvdmUpLlxuICAvLyBBbiBleGFjdCBsZXR0ZXIgbWF0Y2ggd2hpY2ggaXMgJ2Rpc3RhbmNlJyBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZnV6enkgbG9jYXRpb25cbiAgLy8gd291bGQgc2NvcmUgYXMgYSBjb21wbGV0ZSBtaXNtYXRjaC4gQSBkaXN0YW5jZSBvZiAnMCcgcmVxdWlyZXMgdGhlIG1hdGNoIGJlIGF0XG4gIC8vIHRoZSBleGFjdCBsb2NhdGlvbiBzcGVjaWZpZWQsIGEgdGhyZXNob2xkIG9mICcxMDAwJyB3b3VsZCByZXF1aXJlIGEgcGVyZmVjdCBtYXRjaFxuICAvLyB0byBiZSB3aXRoaW4gODAwIGNoYXJhY3RlcnMgb2YgdGhlIGZ1enp5IGxvY2F0aW9uIHRvIGJlIGZvdW5kIHVzaW5nIGEgMC44IHRocmVzaG9sZC5cbiAgZGlzdGFuY2U6IDEwMFxufTtcblxuY29uc3QgQWR2YW5jZWRPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgaXQgZW5hYmxlcyB0aGUgdXNlIG9mIHVuaXgtbGlrZSBzZWFyY2ggY29tbWFuZHNcbiAgdXNlRXh0ZW5kZWRTZWFyY2g6IGZhbHNlLFxuICAvLyBUaGUgZ2V0IGZ1bmN0aW9uIHRvIHVzZSB3aGVuIGZldGNoaW5nIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIFRoZSBkZWZhdWx0IHdpbGwgc2VhcmNoIG5lc3RlZCBwYXRocyAqaWUgZm9vLmJhci5iYXoqXG4gIGdldEZuOiBnZXQsXG4gIC8vIFdoZW4gYHRydWVgLCBzZWFyY2ggd2lsbCBpZ25vcmUgYGxvY2F0aW9uYCBhbmQgYGRpc3RhbmNlYCwgc28gaXQgd29uJ3QgbWF0dGVyXG4gIC8vIHdoZXJlIGluIHRoZSBzdHJpbmcgdGhlIHBhdHRlcm4gYXBwZWFycy5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2Z1enppbmVzcy1zY29yZVxuICBpZ25vcmVMb2NhdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSByZWxldmFuY2Ugc2NvcmUgKHVzZWQgZm9yIHNvcnRpbmcpIHdpbGxcbiAgLy8gaWdub3JlIHRoZSBmaWVsZC1sZW5ndGggbm9ybS5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2ZpZWxkLWxlbmd0aC1ub3JtXG4gIGlnbm9yZUZpZWxkTm9ybTogZmFsc2UsXG4gIC8vIFRoZSB3ZWlnaHQgdG8gZGV0ZXJtaW5lIGhvdyBtdWNoIGZpZWxkIGxlbmd0aCBub3JtIGVmZmVjdHMgc2NvcmluZy5cbiAgZmllbGROb3JtV2VpZ2h0OiAxXG59O1xuXG52YXIgQ29uZmlnID0ge1xuICAuLi5CYXNpY09wdGlvbnMsXG4gIC4uLk1hdGNoT3B0aW9ucyxcbiAgLi4uRnV6enlPcHRpb25zLFxuICAuLi5BZHZhbmNlZE9wdGlvbnNcbn07XG5cbmNvbnN0IFNQQUNFID0gL1teIF0rL2c7XG5cbi8vIEZpZWxkLWxlbmd0aCBub3JtOiB0aGUgc2hvcnRlciB0aGUgZmllbGQsIHRoZSBoaWdoZXIgdGhlIHdlaWdodC5cbi8vIFNldCB0byAzIGRlY2ltYWxzIHRvIHJlZHVjZSBpbmRleCBzaXplLlxuZnVuY3Rpb24gbm9ybSh3ZWlnaHQgPSAxLCBtYW50aXNzYSA9IDMpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG0gPSBNYXRoLnBvdygxMCwgbWFudGlzc2EpO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0KHZhbHVlKSB7XG4gICAgICBjb25zdCBudW1Ub2tlbnMgPSB2YWx1ZS5tYXRjaChTUEFDRSkubGVuZ3RoO1xuXG4gICAgICBpZiAoY2FjaGUuaGFzKG51bVRva2VucykpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChudW1Ub2tlbnMpXG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgZnVuY3Rpb24gaXMgMS9zcXJ0KHgpLCB3ZWlnaHQgbWFrZXMgdGhhdCB2YXJpYWJsZVxuICAgICAgY29uc3Qgbm9ybSA9IDEgLyBNYXRoLnBvdyhudW1Ub2tlbnMsIDAuNSAqIHdlaWdodCk7XG5cbiAgICAgIC8vIEluIHBsYWNlIG9mIGB0b0ZpeGVkKG1hbnRpc3NhKWAsIGZvciBmYXN0ZXIgY29tcHV0YXRpb25cbiAgICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KE1hdGgucm91bmQobm9ybSAqIG0pIC8gbSk7XG5cbiAgICAgIGNhY2hlLnNldChudW1Ub2tlbnMsIG4pO1xuXG4gICAgICByZXR1cm4gblxuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXNlSW5kZXgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sXG4gICAgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodFxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5vcm0gPSBub3JtKGZpZWxkTm9ybVdlaWdodCwgMyk7XG4gICAgdGhpcy5nZXRGbiA9IGdldEZuO1xuICAgIHRoaXMuaXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEluZGV4UmVjb3JkcygpO1xuICB9XG4gIHNldFNvdXJjZXMoZG9jcyA9IFtdKSB7XG4gICAgdGhpcy5kb2NzID0gZG9jcztcbiAgfVxuICBzZXRJbmRleFJlY29yZHMocmVjb3JkcyA9IFtdKSB7XG4gICAgdGhpcy5yZWNvcmRzID0gcmVjb3JkcztcbiAgfVxuICBzZXRLZXlzKGtleXMgPSBbXSkge1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5fa2V5c01hcCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpZHgpID0+IHtcbiAgICAgIHRoaXMuX2tleXNNYXBba2V5LmlkXSA9IGlkeDtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNDcmVhdGVkIHx8ICF0aGlzLmRvY3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmlzQ3JlYXRlZCA9IHRydWU7XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PFN0cmluZz5cbiAgICBpZiAoaXNTdHJpbmcodGhpcy5kb2NzWzBdKSkge1xuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3JtLmNsZWFyKCk7XG4gIH1cbiAgLy8gQWRkcyBhIGRvYyB0byB0aGUgZW5kIG9mIHRoZSBpbmRleFxuICBhZGQoZG9jKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5zaXplKCk7XG5cbiAgICBpZiAoaXNTdHJpbmcoZG9jKSkge1xuICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgaWR4KTtcbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlcyB0aGUgZG9jIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb2YgdGhlIGluZGV4XG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMucmVjb3Jkcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIC8vIENoYW5nZSByZWYgaW5kZXggb2YgZXZlcnkgc3Vic3F1ZW50IGRvY1xuICAgIGZvciAobGV0IGkgPSBpZHgsIGxlbiA9IHRoaXMuc2l6ZSgpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMucmVjb3Jkc1tpXS5pIC09IDE7XG4gICAgfVxuICB9XG4gIGdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpIHtcbiAgICByZXR1cm4gaXRlbVt0aGlzLl9rZXlzTWFwW2tleUlkXV1cbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZHMubGVuZ3RoXG4gIH1cbiAgX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSB8fCBpc0JsYW5rKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCByZWNvcmQgPSB7XG4gICAgICB2OiBkb2MsXG4gICAgICBpOiBkb2NJbmRleCxcbiAgICAgIG46IHRoaXMubm9ybS5nZXQoZG9jKVxuICAgIH07XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIF9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCkge1xuICAgIGxldCByZWNvcmQgPSB7IGk6IGRvY0luZGV4LCAkOiB7fSB9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgIHRoaXMua2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBrZXkuZ2V0Rm4gPyBrZXkuZ2V0Rm4oZG9jKSA6IHRoaXMuZ2V0Rm4oZG9jLCBrZXkucGF0aCk7XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmRzID0gW107XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW3sgbmVzdGVkQXJySW5kZXg6IC0xLCB2YWx1ZSB9XTtcblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgeyBuZXN0ZWRBcnJJbmRleCwgdmFsdWUgfSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgc3ViUmVjb3JkID0ge1xuICAgICAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICAgICAgaTogbmVzdGVkQXJySW5kZXgsXG4gICAgICAgICAgICAgIG46IHRoaXMubm9ybS5nZXQodmFsdWUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJSZWNvcmRzLnB1c2goc3ViUmVjb3JkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBrKSA9PiB7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIG5lc3RlZEFyckluZGV4OiBrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIDtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmRzO1xuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgfTtcblxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgcmVjb3JkczogdGhpcy5yZWNvcmRzXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4KFxuICBrZXlzLFxuICBkb2NzLFxuICB7IGdldEZuID0gQ29uZmlnLmdldEZuLCBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0IH0gPSB7fVxuKSB7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMubWFwKGNyZWF0ZUtleSkpO1xuICBteUluZGV4LnNldFNvdXJjZXMoZG9jcyk7XG4gIG15SW5kZXguY3JlYXRlKCk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5kZXgoXG4gIGRhdGEsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSBkYXRhO1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuLCBmaWVsZE5vcm1XZWlnaHQgfSk7XG4gIG15SW5kZXguc2V0S2V5cyhrZXlzKTtcbiAgbXlJbmRleC5zZXRJbmRleFJlY29yZHMocmVjb3Jkcyk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZSQxKFxuICBwYXR0ZXJuLFxuICB7XG4gICAgZXJyb3JzID0gMCxcbiAgICBjdXJyZW50TG9jYXRpb24gPSAwLFxuICAgIGV4cGVjdGVkTG9jYXRpb24gPSAwLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IGFjY3VyYWN5ID0gZXJyb3JzIC8gcGF0dGVybi5sZW5ndGg7XG5cbiAgaWYgKGlnbm9yZUxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGFjY3VyYWN5XG4gIH1cblxuICBjb25zdCBwcm94aW1pdHkgPSBNYXRoLmFicyhleHBlY3RlZExvY2F0aW9uIC0gY3VycmVudExvY2F0aW9uKTtcblxuICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgcmV0dXJuIHByb3hpbWl0eSA/IDEuMCA6IGFjY3VyYWN5XG4gIH1cblxuICByZXR1cm4gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyBkaXN0YW5jZVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TWFza1RvSW5kaWNlcyhcbiAgbWF0Y2htYXNrID0gW10sXG4gIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGhcbikge1xuICBsZXQgaW5kaWNlcyA9IFtdO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChsZXQgbGVuID0gbWF0Y2htYXNrLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2htYXNrW2ldO1xuICAgIGlmIChtYXRjaCAmJiBzdGFydCA9PT0gLTEpIHtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgIGVuZCA9IGkgLSAxO1xuICAgICAgaWYgKGVuZCAtIHN0YXJ0ICsgMSA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIChpLTEgLSBzdGFydCkgKyAxID0+IGkgLSBzdGFydFxuICBpZiAobWF0Y2htYXNrW2kgLSAxXSAmJiBpIC0gc3RhcnQgPj0gbWluTWF0Y2hDaGFyTGVuZ3RoKSB7XG4gICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgaSAtIDFdKTtcbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzXG59XG5cbi8vIE1hY2hpbmUgd29yZCBzaXplXG5jb25zdCBNQVhfQklUUyA9IDMyO1xuXG5mdW5jdGlvbiBzZWFyY2goXG4gIHRleHQsXG4gIHBhdHRlcm4sXG4gIHBhdHRlcm5BbHBoYWJldCxcbiAge1xuICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICB9ID0ge31cbikge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUykge1xuICAgIHRocm93IG5ldyBFcnJvcihQQVRURVJOX0xFTkdUSF9UT09fTEFSR0UoTUFYX0JJVFMpKVxuICB9XG5cbiAgY29uc3QgcGF0dGVybkxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICAvLyBTZXQgc3RhcnRpbmcgbG9jYXRpb24gYXQgYmVnaW5uaW5nIHRleHQgYW5kIGluaXRpYWxpemUgdGhlIGFscGhhYmV0LlxuICBjb25zdCB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7XG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIGxvY2F0aW9uID4gdGV4dC5sZW5ndGhcbiAgY29uc3QgZXhwZWN0ZWRMb2NhdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvY2F0aW9uLCB0ZXh0TGVuKSk7XG4gIC8vIEhpZ2hlc3Qgc2NvcmUgYmV5b25kIHdoaWNoIHdlIGdpdmUgdXAuXG4gIGxldCBjdXJyZW50VGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIGxldCBiZXN0TG9jYXRpb24gPSBleHBlY3RlZExvY2F0aW9uO1xuXG4gIC8vIFBlcmZvcm1hbmNlOiBvbmx5IGNvbXB1dGVyIG1hdGNoZXMgd2hlbiB0aGUgbWluTWF0Y2hDaGFyTGVuZ3RoID4gMVxuICAvLyBPUiBpZiBgaW5jbHVkZU1hdGNoZXNgIGlzIHRydWUuXG4gIGNvbnN0IGNvbXB1dGVNYXRjaGVzID0gbWluTWF0Y2hDaGFyTGVuZ3RoID4gMSB8fCBpbmNsdWRlTWF0Y2hlcztcbiAgLy8gQSBtYXNrIG9mIHRoZSBtYXRjaGVzLCB1c2VkIGZvciBidWlsZGluZyB0aGUgaW5kaWNlc1xuICBjb25zdCBtYXRjaE1hc2sgPSBjb21wdXRlTWF0Y2hlcyA/IEFycmF5KHRleHRMZW4pIDogW107XG5cbiAgbGV0IGluZGV4O1xuXG4gIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlcywgaGVyZSBmb3Igc3BlZWQgdXBcbiAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBiZXN0TG9jYXRpb24pKSA+IC0xKSB7XG4gICAgbGV0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgY3VycmVudExvY2F0aW9uOiBpbmRleCxcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBjdXJyZW50VGhyZXNob2xkID0gTWF0aC5taW4oc2NvcmUsIGN1cnJlbnRUaHJlc2hvbGQpO1xuICAgIGJlc3RMb2NhdGlvbiA9IGluZGV4ICsgcGF0dGVybkxlbjtcblxuICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBwYXR0ZXJuTGVuKSB7XG4gICAgICAgIG1hdGNoTWFza1tpbmRleCArIGldID0gMTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBiZXN0IGxvY2F0aW9uXG4gIGJlc3RMb2NhdGlvbiA9IC0xO1xuXG4gIGxldCBsYXN0Qml0QXJyID0gW107XG4gIGxldCBmaW5hbFNjb3JlID0gMTtcbiAgbGV0IGJpbk1heCA9IHBhdHRlcm5MZW4gKyB0ZXh0TGVuO1xuXG4gIGNvbnN0IG1hc2sgPSAxIDw8IChwYXR0ZXJuTGVuIC0gMSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpICs9IDEpIHtcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gdGhlIG1hdGNoIGxvY2F0aW9uIHdlIGNhbiBzdHJheVxuICAgIC8vIGF0IHRoaXMgZXJyb3IgbGV2ZWwuXG4gICAgbGV0IGJpbk1pbiA9IDA7XG4gICAgbGV0IGJpbk1pZCA9IGJpbk1heDtcblxuICAgIHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcbiAgICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICBlcnJvcnM6IGksXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCxcbiAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgYmluTWluID0gYmluTWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluTWF4ID0gYmluTWlkO1xuICAgICAgfVxuXG4gICAgICBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgfVxuXG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluTWF4ID0gYmluTWlkO1xuXG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgZXhwZWN0ZWRMb2NhdGlvbiAtIGJpbk1pZCArIDEpO1xuICAgIGxldCBmaW5pc2ggPSBmaW5kQWxsTWF0Y2hlc1xuICAgICAgPyB0ZXh0TGVuXG4gICAgICA6IE1hdGgubWluKGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsIHRleHRMZW4pICsgcGF0dGVybkxlbjtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGJpdCBhcnJheVxuICAgIGxldCBiaXRBcnIgPSBBcnJheShmaW5pc2ggKyAyKTtcblxuICAgIGJpdEFycltmaW5pc2ggKyAxXSA9ICgxIDw8IGkpIC0gMTtcblxuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGogLT0gMSkge1xuICAgICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IGogLSAxO1xuICAgICAgbGV0IGNoYXJNYXRjaCA9IHBhdHRlcm5BbHBoYWJldFt0ZXh0LmNoYXJBdChjdXJyZW50TG9jYXRpb24pXTtcblxuICAgICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICAgIC8vIFNwZWVkIHVwOiBxdWljayBib29sIHRvIGludCBjb252ZXJzaW9uIChpLmUsIGBjaGFyTWF0Y2ggPyAxIDogMGApXG4gICAgICAgIG1hdGNoTWFza1tjdXJyZW50TG9jYXRpb25dID0gKyEhY2hhck1hdGNoO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaFxuICAgICAgYml0QXJyW2pdID0gKChiaXRBcnJbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XG5cbiAgICAgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaFxuICAgICAgaWYgKGkpIHtcbiAgICAgICAgYml0QXJyW2pdIHw9XG4gICAgICAgICAgKChsYXN0Qml0QXJyW2ogKyAxXSB8IGxhc3RCaXRBcnJbal0pIDw8IDEpIHwgMSB8IGxhc3RCaXRBcnJbaiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYml0QXJyW2pdICYgbWFzaykge1xuICAgICAgICBmaW5hbFNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICAgIGVycm9yczogaSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgIGlmIChmaW5hbFNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBJbmRlZWQgaXQgaXNcbiAgICAgICAgICBjdXJyZW50VGhyZXNob2xkID0gZmluYWxTY29yZTtcbiAgICAgICAgICBiZXN0TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG5cbiAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBgbG9jYCwgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxuICAgICAgICAgIGlmIChiZXN0TG9jYXRpb24gPD0gZXhwZWN0ZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgYGJlc3RMb2NhdGlvbmAsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGBleHBlY3RlZExvY2F0aW9uYC5cbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBleHBlY3RlZExvY2F0aW9uIC0gYmVzdExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGhvcGUgZm9yIGEgKGJldHRlcikgbWF0Y2ggYXQgZ3JlYXRlciBlcnJvciBsZXZlbHMuXG4gICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBlcnJvcnM6IGkgKyAxLFxuICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGlmIChzY29yZSA+IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgbGFzdEJpdEFyciA9IGJpdEFycjtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpc01hdGNoOiBiZXN0TG9jYXRpb24gPj0gMCxcbiAgICAvLyBDb3VudCBleGFjdCBtYXRjaGVzICh0aG9zZSB3aXRoIGEgc2NvcmUgb2YgMCkgdG8gYmUgXCJhbG1vc3RcIiBleGFjdFxuICAgIHNjb3JlOiBNYXRoLm1heCgwLjAwMSwgZmluYWxTY29yZSlcbiAgfTtcblxuICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gY29udmVydE1hc2tUb0luZGljZXMobWF0Y2hNYXNrLCBtaW5NYXRjaENoYXJMZW5ndGgpO1xuICAgIGlmICghaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBpbmRpY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pIHtcbiAgbGV0IG1hc2sgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBwYXR0ZXJuLmNoYXJBdChpKTtcbiAgICBtYXNrW2NoYXJdID0gKG1hc2tbY2hhcl0gfHwgMCkgfCAoMSA8PCAobGVuIC0gaSAtIDEpKTtcbiAgfVxuXG4gIHJldHVybiBtYXNrXG59XG5cbmNsYXNzIEJpdGFwU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMuY2h1bmtzID0gW107XG5cbiAgICBpZiAoIXRoaXMucGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFkZENodW5rID0gKHBhdHRlcm4sIHN0YXJ0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBhbHBoYWJldDogY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pLFxuICAgICAgICBzdGFydEluZGV4XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPiBNQVhfQklUUykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgcmVtYWluZGVyID0gbGVuICUgTUFYX0JJVFM7XG4gICAgICBjb25zdCBlbmQgPSBsZW4gLSByZW1haW5kZXI7XG5cbiAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoaSwgTUFYX0JJVFMpLCBpKTtcbiAgICAgICAgaSArPSBNQVhfQklUUztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gbGVuIC0gTUFYX0JJVFM7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoc3RhcnRJbmRleCksIHN0YXJ0SW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCB7IGlzQ2FzZVNlbnNpdGl2ZSwgaW5jbHVkZU1hdGNoZXMgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghaXNDYXNlU2Vuc2l0aXZlKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEV4YWN0IG1hdGNoXG4gICAgaWYgKHRoaXMucGF0dGVybiA9PT0gdGV4dCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgc2NvcmU6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICByZXN1bHQuaW5kaWNlcyA9IFtbMCwgdGV4dC5sZW5ndGggLSAxXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBCaXRhcCBhbGdvcml0aG1cbiAgICBjb25zdCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcbiAgICBsZXQgaGFzTWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jaHVua3MuZm9yRWFjaCgoeyBwYXR0ZXJuLCBhbHBoYWJldCwgc3RhcnRJbmRleCB9KSA9PiB7XG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2godGV4dCwgcGF0dGVybiwgYWxwaGFiZXQsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uICsgc3RhcnRJbmRleCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG5cbiAgICAgIGlmIChpc01hdGNoICYmIGluZGljZXMpIHtcbiAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBpc01hdGNoOiBoYXNNYXRjaGVzLFxuICAgICAgc2NvcmU6IGhhc01hdGNoZXMgPyB0b3RhbFNjb3JlIC8gdGhpcy5jaHVua3MubGVuZ3RoIDogMVxuICAgIH07XG5cbiAgICBpZiAoaGFzTWF0Y2hlcyAmJiBpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5jbGFzcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgfVxuICBzdGF0aWMgaXNNdWx0aU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5tdWx0aVJlZ2V4KVxuICB9XG4gIHN0YXRpYyBpc1NpbmdsZU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5zaW5nbGVSZWdleClcbiAgfVxuICBzZWFyY2goLyp0ZXh0Ki8pIHt9XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoKHBhdHRlcm4sIGV4cCkge1xuICBjb25zdCBtYXRjaGVzID0gcGF0dGVybi5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBudWxsXG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2V4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL149XCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePSguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQgPT09IHRoaXMucGF0dGVybjtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFmaXJlXG5cbmNsYXNzIEludmVyc2VFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpbmRleCA9PT0gLTE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogXmZpbGVcblxuY2xhc3MgUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdwcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIV5maXJlXG5cbmNsYXNzIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtcHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAuZmlsZSRcblxuY2xhc3MgU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdzdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFt0ZXh0Lmxlbmd0aCAtIHRoaXMucGF0dGVybi5sZW5ndGgsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICEuZmlsZSRcblxuY2xhc3MgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1zdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXp6eU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICAgIHRoaXMuX2JpdGFwU2VhcmNoID0gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdmdXp6eSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0YXBTZWFyY2guc2VhcmNoSW4odGV4dClcbiAgfVxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgSW5jbHVkZU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2luY2x1ZGUnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXidcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14nKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBsZXQgbG9jYXRpb24gPSAwO1xuICAgIGxldCBpbmRleDtcblxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBwYXR0ZXJuTGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlc1xuICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuLCBsb2NhdGlvbikpID4gLTEpIHtcbiAgICAgIGxvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuICAgICAgaW5kaWNlcy5wdXNoKFtpbmRleCwgbG9jYXRpb24gLSAxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNNYXRjaCA9ICEhaW5kaWNlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzXG4gICAgfVxuICB9XG59XG5cbi8vIFx1Mjc1N09yZGVyIGlzIGltcG9ydGFudC4gRE8gTk9UIENIQU5HRS5cbmNvbnN0IHNlYXJjaGVycyA9IFtcbiAgRXhhY3RNYXRjaCxcbiAgSW5jbHVkZU1hdGNoLFxuICBQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2gsXG4gIFN1ZmZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VFeGFjdE1hdGNoLFxuICBGdXp6eU1hdGNoXG5dO1xuXG5jb25zdCBzZWFyY2hlcnNMZW4gPSBzZWFyY2hlcnMubGVuZ3RoO1xuXG4vLyBSZWdleCB0byBzcGxpdCBieSBzcGFjZXMsIGJ1dCBrZWVwIGFueXRoaW5nIGluIHF1b3RlcyB0b2dldGhlclxuY29uc3QgU1BBQ0VfUkUgPSAvICsoPz0oPzpbXlxcXCJdKlxcXCJbXlxcXCJdKlxcXCIpKlteXFxcIl0qJCkvO1xuY29uc3QgT1JfVE9LRU4gPSAnfCc7XG5cbi8vIFJldHVybiBhIDJEIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSwgZm9yIHNpbXBsZXIgcGFyc2luZy5cbi8vIEV4YW1wbGU6XG4vLyBcIl5jb3JlIGdvJCB8IHJiJCB8IHB5JCB4eSRcIiA9PiBbW1wiXmNvcmVcIiwgXCJnbyRcIl0sIFtcInJiJFwiXSwgW1wicHkkXCIsIFwieHkkXCJdXVxuZnVuY3Rpb24gcGFyc2VRdWVyeShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoT1JfVE9LRU4pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGxldCBxdWVyeSA9IGl0ZW1cbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdChTUEFDRV9SRSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gJiYgISFpdGVtLnRyaW0oKSk7XG5cbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgcXVlcnlJdGVtID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIDEuIEhhbmRsZSBtdWx0aXBsZSBxdWVyeSBtYXRjaCAoaS5lLCBvbmNlIHRoYXQgYXJlIHF1b3RlZCwgbGlrZSBgXCJoZWxsbyB3b3JsZFwiYClcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgbGV0IGlkeCA9IC0xO1xuICAgICAgd2hpbGUgKCFmb3VuZCAmJiArK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc011bHRpTWF0Y2gocXVlcnlJdGVtKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBzZWFyY2hlcih0b2tlbiwgb3B0aW9ucykpO1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSGFuZGxlIHNpbmdsZSBxdWVyeSBtYXRjaGVzIChpLmUsIG9uY2UgdGhhdCBhcmUgKm5vdCogcXVvdGVkKVxuICAgICAgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpZHggPCBzZWFyY2hlcnNMZW4pIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbaWR4XTtcbiAgICAgICAgbGV0IHRva2VuID0gc2VhcmNoZXIuaXNTaW5nbGVNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH0pXG59XG5cbi8vIFRoZXNlIGV4dGVuZGVkIG1hdGNoZXJzIGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgbWF0Y2hlcywgYXMgb3Bwb3NlZFxuLy8gdG8gYSBzaW5nbCBtYXRjaFxuY29uc3QgTXVsdGlNYXRjaFNldCA9IG5ldyBTZXQoW0Z1enp5TWF0Y2gudHlwZSwgSW5jbHVkZU1hdGNoLnR5cGVdKTtcblxuLyoqXG4gKiBDb21tYW5kLWxpa2Ugc2VhcmNoaW5nXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogR2l2ZW4gbXVsdGlwbGUgc2VhcmNoIHRlcm1zIGRlbGltaXRlZCBieSBzcGFjZXMuZS5nLiBgXmpzY3JpcHQgLnB5dGhvbiQgcnVieSAhamF2YWAsXG4gKiBzZWFyY2ggaW4gYSBnaXZlbiB0ZXh0LlxuICpcbiAqIFNlYXJjaCBzeW50YXg6XG4gKlxuICogfCBUb2tlbiAgICAgICB8IE1hdGNoIHR5cGUgICAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBganNjcmlwdGAgICB8IGZ1enp5LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBmdXp6eSBtYXRjaCBganNjcmlwdGAgICAgICAgfFxuICogfCBgPXNjaGVtZWAgICB8IGV4YWN0LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBhcmUgYHNjaGVtZWAgICAgICAgICAgICAgICAgfFxuICogfCBgJ3B5dGhvbmAgICB8IGluY2x1ZGUtbWF0Y2ggICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBpbmNsdWRlIGBweXRob25gICAgICAgICAgICAgfFxuICogfCBgIXJ1YnlgICAgICB8IGludmVyc2UtZXhhY3QtbWF0Y2ggICAgICAgIHwgSXRlbXMgdGhhdCBkbyBub3QgaW5jbHVkZSBgcnVieWAgICAgICAgfFxuICogfCBgXmphdmFgICAgICB8IHByZWZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBzdGFydCB3aXRoIGBqYXZhYCAgICAgICAgICAgfFxuICogfCBgIV5lYXJsYW5nYCB8IGludmVyc2UtcHJlZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBgZWFybGFuZ2AgfFxuICogfCBgLmpzJGAgICAgICB8IHN1ZmZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBlbmQgd2l0aCBgLmpzYCAgICAgICAgICAgICAgfFxuICogfCBgIS5nbyRgICAgICB8IGludmVyc2Utc3VmZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3QgZW5kIHdpdGggYC5nb2AgICAgICAgfFxuICpcbiAqIEEgc2luZ2xlIHBpcGUgY2hhcmFjdGVyIGFjdHMgYXMgYW4gT1Igb3BlcmF0b3IuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nXG4gKiBxdWVyeSBtYXRjaGVzIGVudHJpZXMgdGhhdCBzdGFydCB3aXRoIGBjb3JlYCBhbmQgZW5kIHdpdGggZWl0aGVyYGdvYCwgYHJiYCxcbiAqIG9yYHB5YC5cbiAqXG4gKiBgYGBcbiAqIF5jb3JlIGdvJCB8IHJiJCB8IHB5JFxuICogYGBgXG4gKi9cbmNsYXNzIEV4dGVuZGVkU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb24sXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBpZ25vcmVMb2NhdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcGFyc2VRdWVyeSh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgY29uZGl0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy51c2VFeHRlbmRlZFNlYXJjaFxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeTtcblxuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgICBzY29yZTogMVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgaW5jbHVkZU1hdGNoZXMsIGlzQ2FzZVNlbnNpdGl2ZSB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGV4dCA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBsZXQgbnVtTWF0Y2hlcyA9IDA7XG4gICAgbGV0IGFsbEluZGljZXMgPSBbXTtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG5cbiAgICAvLyBPUnNcbiAgICBmb3IgKGxldCBpID0gMCwgcUxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IHFMZW47IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2VhcmNoZXJzID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIFJlc2V0IGluZGljZXNcbiAgICAgIGFsbEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgIG51bU1hdGNoZXMgPSAwO1xuXG4gICAgICAvLyBBTkRzXG4gICAgICBmb3IgKGxldCBqID0gMCwgcExlbiA9IHNlYXJjaGVycy5sZW5ndGg7IGogPCBwTGVuOyBqICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbal07XG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgaW5kaWNlcywgc2NvcmUgfSA9IHNlYXJjaGVyLnNlYXJjaCh0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG51bU1hdGNoZXMgKz0gMTtcbiAgICAgICAgICB0b3RhbFNjb3JlICs9IHNjb3JlO1xuICAgICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHNlYXJjaGVyLmNvbnN0cnVjdG9yLnR5cGU7XG4gICAgICAgICAgICBpZiAoTXVsdGlNYXRjaFNldC5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFsbEluZGljZXMucHVzaChpbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxTY29yZSA9IDA7XG4gICAgICAgICAgbnVtTWF0Y2hlcyA9IDA7XG4gICAgICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT1IgY29uZGl0aW9uLCBzbyBpZiBUUlVFLCByZXR1cm5cbiAgICAgIGlmIChudW1NYXRjaGVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgICBzY29yZTogdG90YWxTY29yZSAvIG51bU1hdGNoZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90aGluZyB3YXMgbWF0Y2hlZFxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgIHNjb3JlOiAxXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHJlZ2lzdGVyZWRTZWFyY2hlcnMgPSBbXTtcblxuZnVuY3Rpb24gcmVnaXN0ZXIoLi4uYXJncykge1xuICByZWdpc3RlcmVkU2VhcmNoZXJzLnB1c2goLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaGVyKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlZ2lzdGVyZWRTZWFyY2hlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgc2VhcmNoZXJDbGFzcyA9IHJlZ2lzdGVyZWRTZWFyY2hlcnNbaV07XG4gICAgaWYgKHNlYXJjaGVyQ2xhc3MuY29uZGl0aW9uKHBhdHRlcm4sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IHNlYXJjaGVyQ2xhc3MocGF0dGVybiwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbmNvbnN0IExvZ2ljYWxPcGVyYXRvciA9IHtcbiAgQU5EOiAnJGFuZCcsXG4gIE9SOiAnJG9yJ1xufTtcblxuY29uc3QgS2V5VHlwZSA9IHtcbiAgUEFUSDogJyRwYXRoJyxcbiAgUEFUVEVSTjogJyR2YWwnXG59O1xuXG5jb25zdCBpc0V4cHJlc3Npb24gPSAocXVlcnkpID0+XG4gICEhKHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5BTkRdIHx8IHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5PUl0pO1xuXG5jb25zdCBpc1BhdGggPSAocXVlcnkpID0+ICEhcXVlcnlbS2V5VHlwZS5QQVRIXTtcblxuY29uc3QgaXNMZWFmID0gKHF1ZXJ5KSA9PlxuICAhaXNBcnJheShxdWVyeSkgJiYgaXNPYmplY3QocXVlcnkpICYmICFpc0V4cHJlc3Npb24ocXVlcnkpO1xuXG5jb25zdCBjb252ZXJ0VG9FeHBsaWNpdCA9IChxdWVyeSkgPT4gKHtcbiAgW0xvZ2ljYWxPcGVyYXRvci5BTkRdOiBPYmplY3Qua2V5cyhxdWVyeSkubWFwKChrZXkpID0+ICh7XG4gICAgW2tleV06IHF1ZXJ5W2tleV1cbiAgfSkpXG59KTtcblxuLy8gV2hlbiBgYXV0b2AgaXMgYHRydWVgLCB0aGUgcGFyc2UgZnVuY3Rpb24gd2lsbCBpbmZlciBhbmQgaW5pdGlhbGl6ZSBhbmQgYWRkXG4vLyB0aGUgYXBwcm9wcmlhdGUgYFNlYXJjaGVyYCBpbnN0YW5jZVxuZnVuY3Rpb24gcGFyc2UocXVlcnksIG9wdGlvbnMsIHsgYXV0byA9IHRydWUgfSA9IHt9KSB7XG4gIGNvbnN0IG5leHQgPSAocXVlcnkpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXJ5KTtcblxuICAgIGNvbnN0IGlzUXVlcnlQYXRoID0gaXNQYXRoKHF1ZXJ5KTtcblxuICAgIGlmICghaXNRdWVyeVBhdGggJiYga2V5cy5sZW5ndGggPiAxICYmICFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgICByZXR1cm4gbmV4dChjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSkpXG4gICAgfVxuXG4gICAgaWYgKGlzTGVhZihxdWVyeSkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRIXSA6IGtleXNbMF07XG5cbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBpc1F1ZXJ5UGF0aCA/IHF1ZXJ5W0tleVR5cGUuUEFUVEVSTl0gOiBxdWVyeVtrZXldO1xuXG4gICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkoa2V5KSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICBrZXlJZDogY3JlYXRlS2V5SWQoa2V5KSxcbiAgICAgICAgcGF0dGVyblxuICAgICAgfTtcblxuICAgICAgaWYgKGF1dG8pIHtcbiAgICAgICAgb2JqLnNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIG9wZXJhdG9yOiBrZXlzWzBdXG4gICAgfTtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5leHQoaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgaWYgKCFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgcXVlcnkgPSBjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSk7XG4gIH1cblxuICByZXR1cm4gbmV4dChxdWVyeSlcbn1cblxuLy8gUHJhY3RpY2FsIHNjb3JpbmcgZnVuY3Rpb25cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShcbiAgcmVzdWx0cyxcbiAgeyBpZ25vcmVGaWVsZE5vcm0gPSBDb25maWcuaWdub3JlRmllbGROb3JtIH1cbikge1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgIGxldCB0b3RhbFNjb3JlID0gMTtcblxuICAgIHJlc3VsdC5tYXRjaGVzLmZvckVhY2goKHsga2V5LCBub3JtLCBzY29yZSB9KSA9PiB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBrZXkgPyBrZXkud2VpZ2h0IDogbnVsbDtcblxuICAgICAgdG90YWxTY29yZSAqPSBNYXRoLnBvdyhcbiAgICAgICAgc2NvcmUgPT09IDAgJiYgd2VpZ2h0ID8gTnVtYmVyLkVQU0lMT04gOiBzY29yZSxcbiAgICAgICAgKHdlaWdodCB8fCAxKSAqIChpZ25vcmVGaWVsZE5vcm0gPyAxIDogbm9ybSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQuc2NvcmUgPSB0b3RhbFNjb3JlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0Y2hlcyhyZXN1bHQsIGRhdGEpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHJlc3VsdC5tYXRjaGVzO1xuICBkYXRhLm1hdGNoZXMgPSBbXTtcblxuICBpZiAoIWlzRGVmaW5lZChtYXRjaGVzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG1hdGNoLmluZGljZXMpIHx8ICFtYXRjaC5pbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmRpY2VzLCB2YWx1ZSB9ID0gbWF0Y2g7XG5cbiAgICBsZXQgb2JqID0ge1xuICAgICAgaW5kaWNlcyxcbiAgICAgIHZhbHVlXG4gICAgfTtcblxuICAgIGlmIChtYXRjaC5rZXkpIHtcbiAgICAgIG9iai5rZXkgPSBtYXRjaC5rZXkuc3JjO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5pZHggPiAtMSkge1xuICAgICAgb2JqLnJlZkluZGV4ID0gbWF0Y2guaWR4O1xuICAgIH1cblxuICAgIGRhdGEubWF0Y2hlcy5wdXNoKG9iaik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TY29yZShyZXN1bHQsIGRhdGEpIHtcbiAgZGF0YS5zY29yZSA9IHJlc3VsdC5zY29yZTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KFxuICByZXN1bHRzLFxuICBkb2NzLFxuICB7XG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaW5jbHVkZVNjb3JlID0gQ29uZmlnLmluY2x1ZGVTY29yZVxuICB9ID0ge31cbikge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBbXTtcblxuICBpZiAoaW5jbHVkZU1hdGNoZXMpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybU1hdGNoZXMpO1xuICBpZiAoaW5jbHVkZVNjb3JlKSB0cmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1TY29yZSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHtcbiAgICBjb25zdCB7IGlkeCB9ID0gcmVzdWx0O1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGl0ZW06IGRvY3NbaWR4XSxcbiAgICAgIHJlZkluZGV4OiBpZHhcbiAgICB9O1xuXG4gICAgaWYgKHRyYW5zZm9ybWVycy5sZW5ndGgpIHtcbiAgICAgIHRyYW5zZm9ybWVycy5mb3JFYWNoKCh0cmFuc2Zvcm1lcikgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1lcihyZXN1bHQsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfSlcbn1cblxuY2xhc3MgRnVzZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3MsIG9wdGlvbnMgPSB7fSwgaW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLkNvbmZpZywgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoICYmXG4gICAgICAhdHJ1ZVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSlcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlTdG9yZSA9IG5ldyBLZXlTdG9yZSh0aGlzLm9wdGlvbnMua2V5cyk7XG5cbiAgICB0aGlzLnNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpO1xuICB9XG5cbiAgc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCkge1xuICAgIHRoaXMuX2RvY3MgPSBkb2NzO1xuXG4gICAgaWYgKGluZGV4ICYmICEoaW5kZXggaW5zdGFuY2VvZiBGdXNlSW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSU5DT1JSRUNUX0lOREVYX1RZUEUpXG4gICAgfVxuXG4gICAgdGhpcy5fbXlJbmRleCA9XG4gICAgICBpbmRleCB8fFxuICAgICAgY3JlYXRlSW5kZXgodGhpcy5vcHRpb25zLmtleXMsIHRoaXMuX2RvY3MsIHtcbiAgICAgICAgZ2V0Rm46IHRoaXMub3B0aW9ucy5nZXRGbixcbiAgICAgICAgZmllbGROb3JtV2VpZ2h0OiB0aGlzLm9wdGlvbnMuZmllbGROb3JtV2VpZ2h0XG4gICAgICB9KTtcbiAgfVxuXG4gIGFkZChkb2MpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9kb2NzLnB1c2goZG9jKTtcbiAgICB0aGlzLl9teUluZGV4LmFkZChkb2MpO1xuICB9XG5cbiAgcmVtb3ZlKHByZWRpY2F0ZSA9ICgvKiBkb2MsIGlkeCAqLykgPT4gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fZG9jcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgZG9jID0gdGhpcy5fZG9jc1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUoZG9jLCBpKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KGkpO1xuICAgICAgICBpIC09IDE7XG4gICAgICAgIGxlbiAtPSAxO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICByZW1vdmVBdChpZHgpIHtcbiAgICB0aGlzLl9kb2NzLnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuX215SW5kZXgucmVtb3ZlQXQoaWR4KTtcbiAgfVxuXG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9teUluZGV4XG4gIH1cblxuICBzZWFyY2gocXVlcnksIHsgbGltaXQgPSAtMSB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZSxcbiAgICAgIHNob3VsZFNvcnQsXG4gICAgICBzb3J0Rm4sXG4gICAgICBpZ25vcmVGaWVsZE5vcm1cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBpc1N0cmluZyhxdWVyeSlcbiAgICAgID8gaXNTdHJpbmcodGhpcy5fZG9jc1swXSlcbiAgICAgICAgPyB0aGlzLl9zZWFyY2hTdHJpbmdMaXN0KHF1ZXJ5KVxuICAgICAgICA6IHRoaXMuX3NlYXJjaE9iamVjdExpc3QocXVlcnkpXG4gICAgICA6IHRoaXMuX3NlYXJjaExvZ2ljYWwocXVlcnkpO1xuXG4gICAgY29tcHV0ZVNjb3JlKHJlc3VsdHMsIHsgaWdub3JlRmllbGROb3JtIH0pO1xuXG4gICAgaWYgKHNob3VsZFNvcnQpIHtcbiAgICAgIHJlc3VsdHMuc29ydChzb3J0Rm4pO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihsaW1pdCkgJiYgbGltaXQgPiAtMSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQocmVzdWx0cywgdGhpcy5fZG9jcywge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmVcbiAgICB9KVxuICB9XG5cbiAgX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkgc3RyaW5nIGluIHRoZSBpbmRleFxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGl0ZW06IHRleHQsXG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIG1hdGNoZXM6IFt7IHNjb3JlLCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoTG9naWNhbChxdWVyeSkge1xuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgY29uc3QgZXZhbHVhdGUgPSAobm9kZSwgaXRlbSwgaWR4KSA9PiB7XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgeyBrZXlJZCwgc2VhcmNoZXIgfSA9IG5vZGU7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICBrZXk6IHRoaXMuX2tleVN0b3JlLmdldChrZXlJZCksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuX215SW5kZXguZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCksXG4gICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2YWx1YXRlKGNoaWxkLCBpdGVtLCBpZHgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgIHJlcy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gTG9naWNhbE9wZXJhdG9yLkFORCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9teUluZGV4LnJlY29yZHM7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIGxldCBleHBSZXN1bHRzID0gZXZhbHVhdGUoZXhwcmVzc2lvbiwgaXRlbSwgaWR4KTtcblxuICAgICAgICBpZiAoZXhwUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEZWR1cGUgd2hlbiBhZGRpbmdcbiAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpZHhdKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XSA9IHsgaWR4LCBpdGVtLCBtYXRjaGVzOiBbXSB9O1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdE1hcFtpZHhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwUmVzdWx0cy5mb3JFYWNoKCh7IG1hdGNoZXMgfSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0ubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaE9iamVjdExpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgICBrZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIC4uLnRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtW2tleUluZGV4XSxcbiAgICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBtYXRjaGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuICBfZmluZE1hdGNoZXMoeyBrZXksIHZhbHVlLCBzZWFyY2hlciB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgbm9ybSxcbiAgICAgICAgICAgIGluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdjogdGV4dCwgbjogbm9ybSB9ID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goeyBzY29yZSwga2V5LCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9XG59XG5cbkZ1c2UudmVyc2lvbiA9ICc2LjYuMic7XG5GdXNlLmNyZWF0ZUluZGV4ID0gY3JlYXRlSW5kZXg7XG5GdXNlLnBhcnNlSW5kZXggPSBwYXJzZUluZGV4O1xuRnVzZS5jb25maWcgPSBDb25maWc7XG5cbntcbiAgRnVzZS5wYXJzZVF1ZXJ5ID0gcGFyc2U7XG59XG5cbntcbiAgcmVnaXN0ZXIoRXh0ZW5kZWRTZWFyY2gpO1xufVxuXG5leHBvcnQgeyBGdXNlIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgRnVzZSBmcm9tICdmdXNlLmpzJztcbmltcG9ydCB7IGdldEljb25JZHMgfSBmcm9tICdvYnNpZGlhbic7XG5cbmludGVyZmFjZSBJY29uRGVmaW5pdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIGFsaWFzZXM6IHN0cmluZ1tdO1xufVxuXG4vLyBTaW5jZSBPYnNpZGlhbiAxLjcgaW5jbHVkZXMgTHVjaWRlIHYwLjQ0Ni4wLCB3ZSBjYW4gdXNlIGdldEljb25JZHMoKSBkaXJlY3RseVxuZXhwb3J0IGNvbnN0IGljb25MaXN0UmF3OiBJY29uRGVmaW5pdGlvbltdID0gZ2V0SWNvbklkcygpLm1hcChpZCA9PiAoe1xuICBpZCxcbiAgYWxpYXNlczogW10gYXMgc3RyaW5nW11cbn0pKTtcblxuZXhwb3J0IGNvbnN0IGljb25MaXN0ID0gbmV3IEZ1c2UoaWNvbkxpc3RSYXcsIHtcbiAgdGhyZXNob2xkOiAwLjEsXG4gIG1pbk1hdGNoQ2hhckxlbmd0aDogMixcbiAga2V5czogWydpZCcsICdhbGlhc2VzJ10sXG59KTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7OztBQ0FlLDRCQUE0QixRQUFRO0FBQ2xELE1BQUksT0FBTyxXQUFXLFVBQVU7QUFDL0IsVUFBTSxJQUFJLFVBQVU7QUFBQTtBQUtyQixTQUFPLE9BQ0wsUUFBUSx1QkFBdUIsUUFDL0IsUUFBUSxNQUFNO0FBQUE7OztBRFBqQix1QkFBdUQ7OztBRUZ2RCxzQkFBcUQ7QUFDckQsbUJBS087QUFDUCxrQkFPTztBQUNQLHNCQUF3QjtBQUlqQixJQUFNLFlBQVkseUJBQVk7QUFFOUIsc0NBQWdDLHVCQUFXO0FBQUEsRUFDaEQsUUFBUTtBQUNOLFdBQU8sV0FBVztBQUFBLE1BQ2hCLEtBQUs7QUFBQSxNQUNMLE1BQU07QUFBQSxRQUNKLGVBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlyQixLQUFjO0FBQ1osV0FBTztBQUFBO0FBQUE7QUFJSixrQ0FBNEIsdUJBQVc7QUFBQSxFQUk1QyxZQUFZLE1BQWMsTUFBZTtBQUN2QztBQUVBLFNBQUssT0FBTztBQUNaLFNBQUssT0FBTztBQUFBO0FBQUEsRUFHZCxRQUFRO0FBQ04sV0FBTyxXQUNMO0FBQUEsTUFDRSxNQUFNLEtBQUs7QUFBQSxNQUNYLEtBQUs7QUFBQSxNQUNM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
